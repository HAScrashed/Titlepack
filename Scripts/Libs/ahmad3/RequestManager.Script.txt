/************************************************
 *   Obstacle Library
 *   Author:     ahmad3
 *
 *   Request manager, to manage requests in a CMlScriptIngame context
 ***********************************************/

#Include "Libs/ahmad3/AuthUtils.Script.txt" as AuthUtils
#Include "Libs/smokegun/Constants.Script.txt" as Constants

/*********************************************
  CONSTANTS
 *********************************************/

#Const Version "2024-07-25"
#Const ScriptName "RequestManager.Script.txt"

/*********************************************
  TYPES
 *********************************************/

#Struct K_GetRequest {
    Text Route;
    Boolean UseCache;
    Text[Text] Headers;
}

#Struct K_GetRequestWithHost {
    K_GetRequest Req;
    Text Host;
}

#Struct K_PostRequest {
    Text Route;
    Text Body;
    Text[Text] Headers;
}

#Struct K_PostRequestWithHost {
    K_PostRequest Req;
    Text Host;
}

/*********************************************
  GLOBALES
 *********************************************/

declare K_GetRequestWithHost[Integer] G_PendingGetReqs;
declare K_PostRequestWithHost[Integer] G_PendingPostReqs;
declare Integer G_LastPendingReqId;

declare Text G_ObsModeVersion;

/*********************************************
  FUNCTIONS
 *********************************************/

////////////////////
//// Private
////////////////////

Text Private_ML_DefaultHeaders() {
    if (G_ObsModeVersion != "") {
        return """//!
return [
    "ObstacleModeVersion" => {{{dump(G_ObsModeVersion)}}},
    "Content-Type" => "application/json",
    "Accept" => "application/json"
];
        """;
    }

    return """//!
return [
    "Content-Type" => "application/json",
    "Accept" => "application/json"
];
    """;
}

Void Private_AssertSlotsAvailable() {
    assert(Http.SlotsAvailable > 0, "there must be a slot available for the request to perform");
}

Text Private_BuildHeaders(Text[Text] _Headers) {
    declare Text Out = "";
    foreach (HeaderName => Value in _Headers) {
        Out ^= HeaderName ^ ": " ^ Value ^ "\n";
    }
    return Out;
}

Ident Private_MakePostImpl(K_PostRequest _Request, Text _Host) {
    Private_AssertSlotsAvailable();

    declare CHttpRequest Req = Http.CreatePost(
        _Host ^ _Request.Route,
        _Request.Body,
        Private_BuildHeaders(_Request.Headers)
    );

    return Req.Id;
}

Ident Private_MakeGetImpl(K_GetRequest _Request, Text _Host) {
    Private_AssertSlotsAvailable();

    declare CHttpRequest Req = Http.CreateGet(
        _Host ^ _Request.Route,
        _Request.UseCache,
        Private_BuildHeaders(_Request.Headers)
    );

    return Req.Id;
}

////////////////////
//// Public
////////////////////

/**
 * Returns the version of the script module.
 */
Text GetVersion() {
    return Version;
}

/**
 * Returns the name of the script module.
 */
Text GetScriptName() {
    return ScriptName;
}

Void Unload() {
    G_ObsModeVersion = "";
}

Void Load(Text _ObsModeVersion) {
    Unload();
    G_ObsModeVersion = _ObsModeVersion;
}

Text[Text] DefaultHeaders() {
    if (G_ObsModeVersion != "") {
        return [
            "ObstacleModeVersion" => G_ObsModeVersion,
            "Content-Type" => "application/json",
            "Accept" => "application/json"
        ];
    }

    return [
        "Content-Type" => "application/json",
        "Accept" => "application/json"
    ];
}

Text[Text] AuthHeaders(CUser _User) {
    declare Text Token = AuthUtils::GetUserToken(_User);
    return [
        "PlayerLogin" => _User.Login,
        "Authorization" => Token
    ];
}

Text[Text] MergeHeaders(Text[Text] _A, Text[Text] _B) {
    declare Text[Text] Out = _A;
    foreach (HeaderName => Value in _B) {
        Out[HeaderName] = Value;
    }
    return Out;
}

Text[Text] DefaultHeadersWith(Text[Text] _Others) {
    return MergeHeaders(DefaultHeaders(), _Others);
}

Integer LastPendingReqId() {
    return G_LastPendingReqId;
}

Ident Make(K_PostRequest _Request, Text _Host) {
    if (Http.SlotsAvailable > 0) {
        return Private_MakePostImpl(_Request, _Host);
    }

    G_LastPendingReqId += 1;
    G_PendingPostReqs[G_LastPendingReqId] = K_PostRequestWithHost {
        Req = _Request,
        Host = _Host
    };

    return NullId;
}

Ident Make(K_PostRequest _Request) {
    return Make(_Request, Constants::C_HostUrl);
}

Ident Make(K_GetRequest _Request, Text _Host) {
    if (Http.SlotsAvailable > 0) {
        return Private_MakeGetImpl(_Request, _Host);
    }

    G_LastPendingReqId += 1;
    G_PendingGetReqs[G_LastPendingReqId] = K_GetRequestWithHost {
        Req = _Request,
        Host = _Host
    };

    return NullId;
}

Ident Make(K_GetRequest _Request) {
    return Make(_Request, Constants::C_HostUrl);
}

Ident MakePendingPost(Integer _PendingReqId) {
    assert(
        G_PendingPostReqs.existskey(_PendingReqId),
        "the param _PendingReqId must be the ID of a pending request"
    );

    declare K_PostRequestWithHost PendingReq = G_PendingPostReqs[_PendingReqId];
    if (Http.SlotsAvailable > 0) {
        G_PendingPostReqs.removekey(_PendingReqId);
        return Private_MakePostImpl(PendingReq.Req, PendingReq.Host);
    }

    return NullId;
}

Ident MakePendingGet(Integer _PendingReqId) {
    assert(
        G_PendingGetReqs.existskey(_PendingReqId),
        "the param _PendingReqId must be the ID of a pending request"
    );

    declare K_GetRequestWithHost PendingReq = G_PendingGetReqs[_PendingReqId];
    if (Http.SlotsAvailable > 0) {
        G_PendingGetReqs.removekey(_PendingReqId);
        return Private_MakeGetImpl(PendingReq.Req, PendingReq.Host);
    }

    return NullId;
}

Text ML_Preproc(Text _ModName) {
    return """//!
#Struct {{{_ModName}}}_K_GetRequest {
    Text Route;
    Boolean UseCache;
    Text[Text] Headers;
}

#Struct {{{_ModName}}}_K_GetRequestWithHost {
    {{{_ModName}}}_K_GetRequest Req;
    Text Host;
}

#Struct {{{_ModName}}}_K_PostRequest {
    Text Route;
    Text Body;
    Text[Text] Headers;
}

#Struct {{{_ModName}}}_K_PostRequestWithHost {
    {{{_ModName}}}_K_PostRequest Req;
    Text Host;
}
    """;
}

Text ML_Content(Text _ModName) {
    return """//!
{{{AuthUtils::ML_Content(_ModName ^ "_AuthUtils")}}}

declare {{{_ModName}}}_K_GetRequestWithHost[Integer] {{{_ModName}}}_Private_G_PendingGetReqs;
declare {{{_ModName}}}_K_PostRequestWithHost[Integer] {{{_ModName}}}_Private_G_PendingPostReqs;
declare Integer {{{_ModName}}}_Private_G_LastPendingReqId;

Text {{{_ModName}}}_Private_BuildHeaders(Text[Text] _Headers) {
    declare Text Out = "";
    foreach (HeaderName => Value in _Headers) {
        Out ^= HeaderName ^ ": " ^ Value ^ "\n";
    }
    return Out;
}

Void {{{_ModName}}}_Private_AssertSlotsAvailable() {
    assert(Http.SlotsAvailable > 0, "there must be a slot available for the request to perform");
}

Ident {{{_ModName}}}_Private_MakePostImpl({{{_ModName}}}_K_PostRequest _Request, Text _Host) {
    {{{_ModName}}}_Private_AssertSlotsAvailable();

    declare CHttpRequest Req = Http.CreatePost(
        _Host ^ _Request.Route,
        _Request.Body,
        {{{_ModName}}}_Private_BuildHeaders(_Request.Headers)
    );

    return Req.Id;
}

Ident {{{_ModName}}}_Private_MakeGetImpl({{{_ModName}}}_K_GetRequest _Request, Text _Host) {
    {{{_ModName}}}_Private_AssertSlotsAvailable();

    declare CHttpRequest Req = Http.CreateGet(
        _Host ^ _Request.Route,
        _Request.UseCache,
        {{{_ModName}}}_Private_BuildHeaders(_Request.Headers)
    );

    return Req.Id;
}

Text[Text] {{{_ModName}}}_DefaultHeaders() {
    {{{Private_ML_DefaultHeaders()}}}
}

Text[Text] {{{_ModName}}}_AuthHeaders() {
    declare Text Token = {{{_ModName}}}_AuthUtils_GetUserToken();
    return [
        "PlayerLogin" => LocalUser.Login,
        "Authorization" => Token
    ];
}

Text[Text] {{{_ModName}}}_MergeHeaders(Text[Text] _A, Text[Text] _B) {
    declare Text[Text] Out = _A;
    foreach (HeaderName => Value in _B) {
        Out[HeaderName] = Value;
    }
    return Out;
}

Text[Text] {{{_ModName}}}_DefaultHeadersWith(Text[Text] _Others) {
    return {{{_ModName}}}_MergeHeaders({{{_ModName}}}_DefaultHeaders(), _Others);
}

Integer {{{_ModName}}}_LastPendingReqId() {
    return {{{_ModName}}}_Private_G_LastPendingReqId;
}

Ident {{{_ModName}}}_Make({{{_ModName}}}_K_PostRequest _Request, Text _Host) {
    if (Http.SlotsAvailable > 0) {
        return {{{_ModName}}}_Private_MakePostImpl(_Request, _Host);
    }

    {{{_ModName}}}_Private_G_LastPendingReqId += 1;
    {{{_ModName}}}_Private_G_PendingPostReqs[{{{_ModName}}}_Private_G_LastPendingReqId] = {{{_ModName}}}_K_PostRequestWithHost {
        Req = _Request,
        Host = _Host
    };

    return NullId;
}

Ident {{{_ModName}}}_Make({{{_ModName}}}_K_PostRequest _Request) {
    return {{{_ModName}}}_Make(_Request, {{{dump(Constants::C_HostUrl)}}});
}

Ident {{{_ModName}}}_Make({{{_ModName}}}_K_GetRequest _Request, Text _Host) {
    if (Http.SlotsAvailable > 0) {
        return {{{_ModName}}}_Private_MakeGetImpl(_Request, _Host);
    }

    {{{_ModName}}}_Private_G_LastPendingReqId += 1;
    {{{_ModName}}}_Private_G_PendingGetReqs[{{{_ModName}}}_Private_G_LastPendingReqId] = {{{_ModName}}}_K_GetRequestWithHost {
        Req = _Request,
        Host = _Host
    };

    return NullId;
}

Ident {{{_ModName}}}_Make({{{_ModName}}}_K_GetRequest _Request) {
    return {{{_ModName}}}_Make(_Request, {{{dump(Constants::C_HostUrl)}}});
}

Ident {{{_ModName}}}_MakePendingPost(Integer _PendingReqId) {
    assert(
        {{{_ModName}}}_Private_G_PendingPostReqs.existskey(_PendingReqId),
        "the param _PendingReqId must be the ID of a pending request"
    );

    declare {{{_ModName}}}_K_PostRequestWithHost PendingReq =
        {{{_ModName}}}_Private_G_PendingPostReqs[_PendingReqId];
    if (Http.SlotsAvailable > 0) {
        {{{_ModName}}}_Private_G_PendingPostReqs.removekey(_PendingReqId);
        return {{{_ModName}}}_Private_MakePostImpl(PendingReq.Req, PendingReq.Host);
    }

    return NullId;
}

Ident {{{_ModName}}}_MakePendingGet(Integer _PendingReqId) {
    assert(
        {{{_ModName}}}_Private_G_PendingGetReqs.existskey(_PendingReqId),
        "the param _PendingReqId must be the ID of a pending request"
    );

    declare {{{_ModName}}}_K_GetRequestWithHost PendingReq =
        {{{_ModName}}}_Private_G_PendingGetReqs[_PendingReqId];
    if (Http.SlotsAvailable > 0) {
        {{{_ModName}}}_Private_G_PendingGetReqs.removekey(_PendingReqId);
        return {{{_ModName}}}_Private_MakeGetImpl(PendingReq.Req, PendingReq.Host);
    }

    return NullId;

}
    """;
}