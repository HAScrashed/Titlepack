/************************************************
*   Obstacle Library                            *
*   Author:     smokegun                        *
*                                               *
*   Utility functions.                          *
************************************************/

#Include "TextLib" as TextLib
#Include "MathLib" as MathLib
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

/***************************************
    CONSTANTS
***************************************/

#Const  Version     "2017-07-10"
#Const  ScriptName  "Tools.Script.txt"

/***************************************
    FUNCTIONS
***************************************/

Text GetPosn(Vec3 _Posn) {
    return _Posn.X^" "^_Posn.Y^" "^_Posn.Z;
}

Text GetPosn(Vec2 _Posn) {
    return _Posn.X^" "^_Posn.Y;
}

Boolean IsGoal(CSmMapLandmark _Landmark) {
    return _Landmark.Tag == "Goal";
}

Boolean IsEnabled(CSmMapLandmark _Landmark) {
    if(Map::GetMapTypeVersion() <= 2)
        return _Landmark.Tag != "No-Function";
    declare metadata Meta_IsEnabled for _Landmark = True;
    return Meta_IsEnabled;
}

Boolean IsCheckpoint(CSmMapLandmark _Landmark) {
    if(Map::GetMapTypeVersion() <= 2)
        return "Checkpoint" == TextLib::SubText(_Landmark.Tag, 0, 10);

    return _Landmark.Tag == "Checkpoint";
}

Boolean IsPortal(CSmMapLandmark _Landmark) {
    if(Map::GetMapTypeVersion() <= 2)
        return _Landmark.Tag == "Portal" || _Landmark.Tag == "CheckpointType3";
    declare metadata Meta_IsPortal for _Landmark = False;
    return Meta_IsPortal;
}

Boolean IsCpSpawn(CSmMapLandmark _Landmark) {
    if(Map::GetMapTypeVersion() <= 2)
        return _Landmark.Tag == "CPSpawn";
    declare metadata Meta_IsCpSpawn for _Landmark = False;
    return Meta_IsCpSpawn;
}

Boolean IsSpawn(CSmMapLandmark _Landmark) {
    if(Map::GetMapTypeVersion() <= 2)
        return TextLib::SubString(_Landmark.Tag, 0, 5) == "Spawn";
    declare metadata Meta_IsCpSpawn for _Landmark = False;
    return !Meta_IsCpSpawn;
}

Integer GetWeaponTypeFromSpawn(CSmMapLandmark SpawnLandmark) {
    declare WeaponType = 0;
    declare SpawnName = SpawnLandmark.Tag;
    if (TextLib::Length(SpawnName) > 5) {
        WeaponType = TextLib::ToInteger(TextLib::SubString(SpawnName, 9, 1));
    }
  return WeaponType;
}

Ident Private_GetClosestSpawn(Ident _CheckPointId, Ident[] _SpawnIds) {
    declare Checkpoint <=> MapLandmarks_Gauge[_CheckPointId];
    declare ClosestSpawn = NullId;
    declare ClosestDistance = -1.0;

    foreach (Id in _SpawnIds) {
        if (!MapLandmarks_PlayerSpawn.existskey(Id))
            continue;

        declare Spawn <=> MapLandmarks_PlayerSpawn[Id];
        declare Distance = MathLib::Distance(Checkpoint.Position, Spawn.Position);

        if (Distance < ClosestDistance || ClosestDistance < 0) {
            ClosestDistance = Distance;
            ClosestSpawn = Spawn.Id;
        }
    }

    return ClosestSpawn;
}

Ident GetClosestSpawn(Ident _CheckPointId) {
    declare Checkpoint <=> MapLandmarks_Gauge[_CheckPointId];
    declare SpawnIds = Ident[];

    foreach (Spawn in MapLandmarks_PlayerSpawn) {
        if (IsCpSpawn(Spawn) && (Checkpoint.Order == 0 || Checkpoint.Order == Spawn.Order))
            SpawnIds.add(Spawn.Id);
    }

    if (SpawnIds.count > 0)
        return Private_GetClosestSpawn(_CheckPointId, SpawnIds);

    // If there is no spawn for the current checkpoint
    // Search for previous spawns
    foreach (Spawn in MapLandmarks_PlayerSpawn) {
        if (IsCpSpawn(Spawn) && Checkpoint.Order > Spawn.Order)
            SpawnIds.add(Spawn.Id);
    }

    return Private_GetClosestSpawn(_CheckPointId, SpawnIds);
}

Integer GetPlayerRank(CSmPlayer _Player) {
    declare LastCheckpointId for _Player = NullId;
    declare BestRun for _Player.Score = -1;
    declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
    declare Ranking = Integer[Ident];

    // Player is finishing a run
    if(CheckpointsTimeLast.count == 0) {

        // Fill ranking with every player who has finished the map
        foreach (Score in Scores) {
            declare BestRun for Score = -1;
            if (BestRun < 0) continue;
            Ranking[Score.User.Id] = BestRun;
        }

    // Player has taken a checkpoint
    } else {

        // Fill ranking with every player who has best time at last checkpoint
        foreach (Score in Scores) {
            declare CheckpointsTimeBest for Score = Integer[Ident];
            if (!CheckpointsTimeBest.existskey(LastCheckpointId)) continue;
            Ranking[Score.User.Id] = CheckpointsTimeBest[LastCheckpointId];
        }
    }

    if(Ranking.count == 0) {
        return 0;
    }

    // Rank players by time
    Ranking = Ranking.sort();


    declare Rank = 1;
    // Get final rank
    foreach (UserId => Time in Ranking) {
        if (UserId == _Player.User.Id) break;
        Rank += 1;
    }

    return Rank;
}