/************************************************
 *   Obstacle Library                            *
 *   Author:     ahmad3                          *
 *                                               *
 *   Util functions for auth system              *
 ************************************************/

#Include "MathLib" as MathLib
#Include "TimeLib" as TimeLib
#Include "Libs/smokegun/Constants.Script.txt" as Constants
#Include "Libs/miltant/RunFlags.Script.txt" as RunFlags

#Include "Libs/ahmad3/Error.Script.txt" as Error
#Include "Libs/ahmad3/Ban.Script.txt" as Ban

/*********************************************
  CONSTANTS
 *********************************************/

#Const  Version     "2023-07-09"
#Const  ScriptName  "MlAuth.Script.txt"

Text GetLayer() {
	return """
<manialink version="3" name="Obstacle:Auth">
<script><!--

#Include "MathLib" as MathLib
#Include "TimeLib" as TimeLib
#Include "TextLib" as TL

//#Const C_HostUrl "https://obstacle.titlepack.io/api/"
#Const C_HostUrl "http://192.168.1.30:3001/"
#Const C_MP_App_Id			"de1ce3ba8e"
#Const C_MP_Link				"https://prod.live.maniaplanet.com/login/oauth2/authorize?response_type=code&"
//#Const C_MP_Redirect   "https://obstacle.titlepack.io/give_token"
#Const C_MP_Redirect   "http://192.168.1.30:8000/give_token"

#Struct K_GetTokenBody {
	Text login;
	Text state;
	Text redirect_uri;
}

#Struct K_GetTokenResponse {
	Text token;
}

#Struct SRequestData {
    Text Headers;
    Text Url;
    Text Data;
}

#Struct K_UpdatePlayerBody {
    Text login;
    Text name;
    Text zone_path;
}

#Struct K_HasFinishedBody {
    Integer time;
    Integer respawn_count;
    Text login;
    Text map_uid;
    Integer flags;
    Integer[] cps;
}

{{{Ban::ML_Preproc()}}}
{{{Error::ML_Preproc()}}}
{{{RunFlags::ML_Preproc()}}}

{{{Ban::ML_Content()}}}
{{{Error::ML_Content()}}}
{{{RunFlags::ML_FlagSum()}}}

declare Boolean G_Errored;

// Used to create a POST request
Ident MakePost(Text _Url, Text _Data) {
    if (Http.SlotsAvailable > 0) {
        log(" Sending request to "^_Url);
        log(" Payload: "^_Data);
		declare persistent ObsStore_UserToken for LocalUser = "";
        declare request <=> Http.CreatePost({{{dump(Constants::C_HostUrl)}}}^_Url, _Data, "Content-Type: application/json\nAccept: application_json\nPlayerLogin: " ^ InputPlayer.User.Login ^ "\nAuthorization: " ^ ObsStore_UserToken);
        return request.Id;
    }
    return NullId;
}

Void Private_UpdateToken() {
	log("Updating token...");

	declare persistent Text ObsStore_UserToken for LocalUser;
	
	declare login = LocalUser.Login;
	declare Text state = login ^ Now;
	declare body = K_GetTokenBody {
		login = login,
		state = state,
		redirect_uri = C_MP_Redirect
	};
	
	declare Req = MakePost("player/get_token", body.tojson());
	if (Req == NullId) {
		log("Could not send request to server");
		G_Errored = True;
		return;
	}

	declare req <=> Http.Requests[Req];

	OpenLink(C_MP_Link
		^ "client_id=" ^ C_MP_App_Id
		^ "&redirect_uri=" ^ C_MP_Redirect
		^ "&state=" ^ state
		^ "&scope=basic",
		CMlScript::LinkType::ExternalBrowser);
	
	wait(req.IsCompleted);
	if (req.StatusCode != 200) {
		declare err = Error_Handle(req.StatusCode, req.Result);
		UI.SendChat(err.message);
		G_Errored = True;
		return;
	}
	
	declare K_GetTokenResponse response;
	response.fromjson(req.Result);
	ObsStore_UserToken = response.token;
	
	log("Token updated!");
}

Boolean usedRSBug(CSmPlayer _Player) {
    declare netread Boolean Net_UsedRSBug for _Player = False;
    return Net_UsedRSBug;
}

Boolean usedAltGlitch(CSmPlayer _Player) {
    declare netread Boolean Net_UsedAltGlitch for _Player = False;
    return Net_UsedAltGlitch;
}

Boolean usedPvPWeapons(CSmPlayer _Player) {
    declare netread Boolean Net_UsedPvPWeapons for _Player = False;
    return Net_UsedPvPWeapons;
}

Boolean usedPvPCollisions(CSmPlayer _Player) {
    declare netread Boolean Net_UsedPvPCollisions for _Player = False;
    return Net_UsedPvPCollisions;
}

Boolean usedSpeedHack(CSmPlayer _Player) {
    declare netread Boolean Net_UsedSpeedHack for _Player = False;
    return Net_UsedSpeedHack;
}

// Send records
Void Private_PlayerFinished(Integer _LastRun, Integer _RespawnCount, Integer[] _LastCpTimes) {
    declare Flags = GetFlagsSum(
        usedRSBug(InputPlayer),
        usedAltGlitch(InputPlayer),
        usedPvPWeapons(InputPlayer),
        usedPvPCollisions(InputPlayer),
        usedSpeedHack(InputPlayer)
    );

    declare state = InputPlayer.User.Login ^ Now;

    declare body = K_HasFinishedBody {
        time = _LastRun,
        respawn_count = _RespawnCount,
        login = InputPlayer.User.Login,
        map_uid = ""^Map.Id,
        flags = Flags,
        cps = _LastCpTimes
    };

    declare Req = MakePost("player/finished", body.tojson());
	if (Req == NullId) {
		log("Could not send request to server");
		return;
	}

	declare req <=> Http.Requests[Req];

	wait (req.IsCompleted);

	if (req.StatusCode == C_HttpErr_Unauthorized && !G_Errored) {
		Private_UpdateToken();
		return Private_PlayerFinished(_LastRun, _RespawnCount, _LastCpTimes);
	} else if (req.StatusCode != 200) {
		declare err = Error_Handle(req.StatusCode, req.Result);
		SendCustomEvent("ban:update", [InputPlayer.User.Login, err.ban.tojson()]);
		UI.SendChat(err.message);
	} else {
		declare netwrite Net_RecordsUpdated for UI = 0;
		Net_RecordsUpdated = Now;
		log("Records updated");
	}

	Http.Destroy(req);
}

// Update player infos
Void Private_UpdatePlayer() {
    declare body = K_UpdatePlayerBody {
        login = InputPlayer.User.Login,
        name = InputPlayer.User.Name,
        zone_path = InputPlayer.User.ZonePath
    };

    declare Req = MakePost("player/update", body.tojson());
	if (Req == NullId) {
		log("Could not send request to server");
		return;
	}

	declare req <=> Http.Requests[Req];
	
	wait (req.IsCompleted);

	if (req.StatusCode == C_HttpErr_Unauthorized && !G_Errored) {
		Private_UpdateToken();
		return Private_UpdatePlayer();
	} else if (req.StatusCode != 200) {
		declare err = Error_Handle(req.StatusCode, req.Result);
		SendCustomEvent("ban:update", [InputPlayer.User.Login, err.ban.tojson()]);
		UI.SendChat(err.message);
	}

	Http.Destroy(Http.Requests[Req]);
}

main() {
	Error_Init();
	declare lastTokenUpdate = -1;
	wait(InputPlayer != Null && Page != Null);

	Private_UpdatePlayer();
    declare netread _LastRun for UI = -1;
    declare netread _RespawnCount for UI = 0;
    declare netread Integer[] _LastCPTimes for UI;
    declare LastRun_Cache = _LastRun;
    declare RespawnCount_Cache = _RespawnCount;
	
	declare netwrite Net_RecordsUpdated for UI = False;

	while (True) {
		yield;

		if (_LastRun != LastRun_Cache || _RespawnCount != RespawnCount_Cache) {
			if (_LastRun > 0) {
				Private_PlayerFinished(_LastRun, _RespawnCount, _LastCPTimes);
			}
			LastRun_Cache = _LastRun;
			RespawnCount_Cache = _RespawnCount;
		}
	}
}

--></script>
</manialink>
	""";
}