/************************************************
*	Obstacle Library								               *
*	Author:		smokegun				                     *
*												                         *
*	Utility functions.   			                   *
************************************************/

#Include "TextLib" as TextLib
#Include "MathLib" as MathLib

/***************************************
	CONSTANTS
***************************************/

#Const	Version		"2017-07-10"
#Const	ScriptName	"Tools.Script.txt"

/***************************************
	FUNCTIONS
***************************************/

Text GetPosn(Vec3 _Posn) {
	return _Posn.X^" "^_Posn.Y^" "^_Posn.Z;
}

Text GetPosn(Vec2 _Posn) {
	return _Posn.X^" "^_Posn.Y;
}

Integer GetWeaponTypeFromSpawn(CSmMapLandmark SpawnLandmark) {
	declare WeaponType = 0;
	declare SpawnName = SpawnLandmark.Tag;
	if (TextLib::Length(SpawnName) > 5) {
		WeaponType = TextLib::ToInteger(TextLib::SubString(SpawnName, 9, 1));
	}
  return WeaponType;
}

Ident Private_GetClosestSpawn(Ident _CheckPointId, Ident[] _SpawnIds) {
	declare Checkpoint <=> MapLandmarks_Gauge[_CheckPointId];
	declare ClosestSpawn = NullId;
	declare ClosestDistance = -1.0;
	
	foreach (Id in _SpawnIds) {
		if (!MapLandmarks_PlayerSpawn.existskey(Id))
			continue;

		declare Spawn <=> MapLandmarks_PlayerSpawn[Id];
		declare Distance = MathLib::Distance(Checkpoint.Position, Spawn.Position);
		
		if (Distance < ClosestDistance || ClosestDistance < 0) {
			ClosestDistance = Distance;
			ClosestSpawn = Spawn.Id;
		}
	}
	
	return ClosestSpawn;
}

Ident GetClosestSpawn(Ident _CheckPointId) {
	declare Checkpoint <=> MapLandmarks_Gauge[_CheckPointId];
	declare SpawnIds = Ident[];

	foreach (Spawn in MapLandmarks_PlayerSpawn) {
		if (Spawn.Tag == "CPSpawn" && (Checkpoint.Order == 0 || Checkpoint.Order == Spawn.Order))
			SpawnIds.add(Spawn.Id);
	}
	
	if (SpawnIds.count > 0)
		return Private_GetClosestSpawn(_CheckPointId, SpawnIds);

	// If there is no spawn for the current checkpoint
	// Search for previous spawns
	foreach (Spawn in MapLandmarks_PlayerSpawn) {
		if (Spawn.Tag == "CPSpawn" && Checkpoint.Order > Spawn.Order)
			SpawnIds.add(Spawn.Id);
	}
	
	return Private_GetClosestSpawn(_CheckPointId, SpawnIds);
}

Boolean IsCheckpoint(CSmMapLandmark _Landmark) {
	return "Checkpoint" == TextLib::SubText(_Landmark.Tag, 0, 10);
}

Boolean IsPortal(CSmMapLandmark _Landmark) {
	return _Landmark.Tag == "Portal" || _Landmark.Tag == "CheckpointType3";
}

Boolean IsSpawn(CSmMapLandmark _Landmark) {
	return TextLib::SubString(_Landmark.Tag, 0, 5) == "Spawn";
}

Integer GetPlayerRank(CSmPlayer _Player) {
	declare Rank = 1;
	declare LastCheckpointId for _Player = NullId;
	declare BestRun for _Player.Score = -1;
	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	declare Ranking = Integer[Ident];

	// Player is finishing a run
	if(CheckpointsTimeLast.count == 0) {

		// Fill ranking with every player who has finished the map
		foreach (Score in Scores) {
			declare BestRun for Score = -1;
			if (BestRun < 0) continue;
			Ranking[Score.User.Id] = BestRun;
		}

	// Player has taken a checkpoint
	} else {

		// Fill ranking with every player who has best time at last checkpoint
		foreach (Score in Scores) {
			declare CheckpointsTimeBest for Score = Integer[Ident];
			if (!CheckpointsTimeBest.existskey(LastCheckpointId)) continue;
			Ranking[Score.User.Id] = CheckpointsTimeBest[LastCheckpointId];
		}
	}

	// Rank players by time
	Ranking = Ranking.sort();

	// Get final rank
	foreach (UserId => Time in Ranking) {
		if (UserId == _Player.User.Id) break;
		Rank += 1;
	}

	return Rank;
}