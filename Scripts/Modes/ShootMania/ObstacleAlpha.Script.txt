/**
 *	Mode obstacle
 */

#Extends "Modes/ShootMania/Base/ModeShootmania.Script.txt"

#Const CompatibleMapTypes		"ObstacleArena,ObstacleTitleArena,TimeAttackArena"
#Const	Version							"1.1"
#Const	ScriptName					"Modes/ShootMania/ObstacleAlpha.Script.txt"

// ---------------------------------- //
// Libraries
// ---------------------------------- //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Env.Script.txt" as Env
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/smokegun/ObstacleLib.Script.txt" as Obstacle
#Include "Libs/smokegun/UI.Script.txt" as ObsUI
#Include "Libs/smokegun/RecordsUI.Script.txt" as RecordsUI
#Include "Libs/smokegun/Items.Script.txt" as Items
#Include "Libs/smokegun/ObstacleRecords.Script.txt" as API
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/steeffeen/CheckpointTimes.Script.txt" as CPTimes

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeLimit 30 as _("Time limit") ///< Time limit on a map
#Setting S_PvPWeapons			False	as _("Enable PvP Weapons")
#Setting S_FullAmmoSpawn			True	as _("Spawning with full Ammunition")
#Setting S_FastRespawn			True	as _("Fast respawn on the checkpoint")
#Setting S_LegacyRespawn	False as _("Enable old respawn")
#Setting S_AllowJump	True as _("Enable checkpoint jumping")
#Setting S_NextMapVotingRatio	0.7		as "<hidden>"
#Setting S_RecordsWidgetTitle "Records" as "Records widget title"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_HudModulePath "Obstacle/testUI.Module.Gbx" ///< Path to the hud module

#Const Description _("Finish map as fast as possible !")
#Const C_DefaultTimeLimit 30

// ---------------------------------- //
// Extends
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
***

/*
***MB_Private_LoadLibraries***
***
Env::Set(Env::Env_Development());
***
*/

***Match_Settings***
***
MB_Settings_UseDefaultHud = False;
MB_Settings_UseDefaultTimer = False;

UsePvPCollisions = False;
UseClans = False;
UseSameWallJump = True;
UsePvPWeapons = S_PvPWeapons;
***

***Match_Rules***
***
ModeInfo::SetName("Obstacle");
ModeInfo::SetType(ModeInfo::Type_FreeForAll());

declare OpenSpecial1Text = "$<$00f";
	declare OpenSpecial2Text = "$<$88f";
	declare OpenSpecial3Text = "$<$0f0";
	declare OpenSpecial4Text = "$<$f80";
	declare OpenBoldText = "$<$o";
	declare OpenSettingText = "$<$08f";
	declare CloseText = "$>";
	
	declare ModeRules = """
Finish the {{{OpenSpecial2Text}}}Obstacle Course{{{CloseText}}} as fast as possible.	
To validate a Race you must touch the Finish after going through all the {{{OpenSpecial2Text}}}Checkpoints{{{CloseText}}}.
You can start over and improve your Time as often as you want during {{{OpenSettingText^S_TimeLimit^CloseText}}} Minutes.
The Player with the best Time wins the Map.
Press the {{{OpenBoldText}}}Respawn{{{CloseText}}} Button (default: {{{OpenSpecial2Text}}}Backspace{{{CloseText}}}) or die to {{{OpenSpecial3Text}}}Respawn{{{CloseText}}} at the last reached Checkpoint.
Press the {{{OpenBoldText}}}Give Up{{{CloseText}}} Button (default: {{{OpenSpecial2Text}}}Delete{{{CloseText}}}) to {{{OpenSpecial3Text}}}Restart{{{CloseText}}} from the beginning. (You can also set another Restart Button at the bottom.)

Press {{{OpenSpecial4Text}}}F3{{{CloseText}}} when you're ready for the next Map (Press F3 again to change your Decision).
Press {{{OpenSpecial4Text}}}F4{{{CloseText}}} to disable/enable Respawning at Checkpoints.
Press {{{OpenSpecial4Text}}}F6{{{CloseText}}} to get an Overview of the Map.
""";


ModeInfo::SetRules(ModeRules);
//L16N [Melee] Short description of the Obstacle game mode rules
ModeInfo::SetStatusMessage(_("Run."));
***

***Match_LoadHud***
***
Hud_Load(C_HudModulePath);
if (Hud != Null && Hud.ScoresTable != Null) {
	Hud.ScoresTable.Scores_Sort(CModulePlaygroundScoresTable::EScoreSortOrder::SMPoints);
	
	// Tabs
	Tabs::Load();
	declare TabsLayer <=> Tabs::CreateTabPaneLayer(["ScoresTab" => "Rankings", "CPTimes" => "Race"], 13, -50, False);
	TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
	UIManager.UIAll.UILayers.add(TabsLayer);
	
	// Checkpoint times
	CPTimes::Load("CPTimes");
	CPTimes::SetSize(<240., 100.>);
	CPTimes::SetBackgroundImage("file://Media/Manialinks/Shootmania/Common/topsBg.dds", <242., 200.>, <0., 6.>);
	CPTimes::Build();
}
***

***Match_SpawnScreen***
***
SpawnScreen::CreateScores("Score.Points");
***

***Match_InitServer***
***
declare Integer G_LastUpdate;
***

***Match_StartServer***
***
G_LastUpdate = 0;
ObsUI::SetNextMapVotingRatio(S_NextMapVotingRatio);
Items::Init();
CreateUI();	
API::Init();
***

***Match_InitMap***
***
declare Integer PrevTimeLimit;
declare Boolean PrevPvPWeapons;
declare Text PrevRecordsWidgetTitle;
***

***Match_StartMap***
***
PrevTimeLimit = S_TimeLimit;
PrevPvPWeapons = S_PvPWeapons;
PrevRecordsWidgetTitle = S_RecordsWidgetTitle;

// map is invalid
if(!Obstacle::PrepareMap()) {
	MB_StopMap();
}

CPTimes::Synchro();

// map specific ui
UIManager.UIAll.MarkersXML = ObsUI::CreateHud3dMarkers();
Layers::Get("Markers").ManialinkPage = ObsUI::CreateLayerMarkers();

Items::Place();

foreach(Player in AllPlayers) {
	declare netwrite Boolean Net_Initialized for Player = False;
	Net_Initialized = False;
	Obstacle::InitPlayer(Player);
}

StartTime = Now;
if (S_TimeLimit > 0) {
	EndTime = (StartTime + S_TimeLimit * 1000 * 60);
} else {
	EndTime = (StartTime + C_DefaultTimeLimit * 1000 * 60);
}

if (Hud != Null && Hud.ScoresTable != Null) {
	//L16N [Melee] Message displayed in the scores table footer informing the players about the current points limit to reach in order to win.
	Hud.ScoresTable.SetFooterText(TL::Compose("%1 "^TL::TimeToText(S_TimeLimit * 60 * 1000), _("Time limit : ")));
}
***

***Match_PlayLoop***
***
// Initalize player who joins as spectator
foreach(Player in Spectators) {
	Obstacle::InitPlayer(Player);
}

API::Loop();

// victory conditions
if (Now > EndTime) {
	Message::SendBigMessage(
		//L16N [Melee] Message displayed when the time limit is reached.
		_("Time limit reached"),
		2000, 3, CUIConfig::EUISound::Silence, 0
	);
	MB_StopMatch();
}

// Manage events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim != Null && Event.Victim.IsInOffZone) {
				// Offzone item active?
				declare netwrite ItemBuffTimes for Event.Victim = Integer[Text];
				if (ItemBuffTimes.existskey(Items::T_ItemOffzone) &&
					 ItemBuffTimes[Items::T_ItemOffzone] >= Now) {
					// Item effect lets player walk through offzone
					Discard(Event);
					continue;
				}
			}
			Obstacle::RespawnPlayer(Event.Victim);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			Obstacle::RespawnPlayer(Event.Player, Event.GiveUp);
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerTouchesObject: {
			if (Event.Object != Null && Event.Player != Null && Items::PickupItems(Event)) {
				PassOn(Event);
			}
			else {
				Discard(Event);
			}
		}
		default: {
			PassOn(Event);
		}
	}
}

foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		// Spawn players
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			if (!Player.RequestsSpectate) {
				Obstacle::RespawnPlayer(Player);
			}
		}
		// Handle checkpoints,etc
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.CapturedLandmark == Null || Player.Score == Null) continue;

			// Manage item effects
			declare netwrite ItemBuffTimes for Player = Integer[Text];
			foreach (ItemName => BuffTime in ItemBuffTimes) {
				if (BuffTime < Now) continue;
				switch (ItemName) {
					// Progressively grant ammo
					case Items::T_ItemAmmo: {
						declare AmmoItemBuffDuration for Player = 0.;
						if (AmmoItemBuffDuration <= 0.) continue;
						declare AmmoItemBuffAmount for Player = 1.;
						declare TickAmount = AmmoItemBuffAmount / (AmmoItemBuffDuration * 1000. / Period);
						AddPlayerAmmo(Player, SM::GetWeapon(Player.CurWeapon), TickAmount);
					}
				}
			}

			Obstacle::HandleCapture(Player);
		}
	}
}

// Process Jumps
declare JumpRequests = CPTimes::PendingJumps();
foreach (Player => CheckpointNumber in JumpRequests) {
	Obstacle::JumpToCheckpoint(Player, CheckpointNumber);
}

// Update settings at runtime
if (PrevTimeLimit != S_TimeLimit) {
	PrevTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) {
		EndTime = StartTime + (S_TimeLimit * 60 * 1000);
	} else {
		EndTime = StartTime + (C_DefaultTimeLimit * 60 * 1000);
	}
	if (Hud != Null && Hud.ScoresTable != Null) {
	//L16N [Melee] Message displayed in the scores table footer informing the players about the current points limit to reach in order to win.
		Hud.ScoresTable.SetFooterText(TL::Compose("%1 "^TL::TimeToText(S_TimeLimit * 60 * 1000), _("Time limit : ")));
	}
}
if (PrevPvPWeapons != S_PvPWeapons) {
	PrevPvPWeapons = S_PvPWeapons;
	UsePvPWeapons = S_PvPWeapons;
}

if (G_LastUpdate + 500 < Now) {
	G_LastUpdate = Now;
	
	if(PrevRecordsWidgetTitle != S_RecordsWidgetTitle) {
		PrevRecordsWidgetTitle = S_RecordsWidgetTitle;
		Layers::Update("Records", RecordsUI::CreateManialink(S_RecordsWidgetTitle));
	}
	ObsUI::UpdateLayerUtilities();
	Obstacle::SetSettings(S_FullAmmoSpawn, S_FastRespawn, S_LegacyRespawn, S_AllowJump);
}
***


***Match_EndMap***
***
Items::Destroy();
EndTime = -1;

SM::UnspawnAllPlayers();

declare BestPlayerScore <=> Scores::GetBestPlayerMapPoints(Scores::C_Order_Descending);
if (BestPlayerScore != Null) {
	Scores::SetPlayerWinner(BestPlayerScore);
} else {
	Scores::ResetPlayerWinner();
}
***

***MB_Private_BeforeCloseLadder***
***
declare Unranked = CSmScore[];

declare WorstRun = -1;
foreach (Score in Scores) {
	declare BestRun for Score = 1;
	if (BestRun > 0) {
		Score.LadderRankSortValue = BestRun;

		if(BestRun > WorstRun) WorstRun = BestRun;
	}
	else {
		Unranked.add(Score);
	}
}

foreach(Score in Unranked) {
	Score.LadderRankSortValue = WorstRun + 1;
}
***

***MB_Private_AfterCloseLadder***
***
DoNothing();
***

***Match_EndServer***
***
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();

Layers::Detach("Info");
Layers::Detach("TimeDiff");
Layers::Detach("Utils");
Layers::Detach("Markers");
Layers::Detach("Items");
Layers::Detach("Records");
UIManager.UILayerDestroyAll();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //
// ---------------------------------- //
Void DoNothing(){}

Void CreateUI() {
	Layers::Create("Info", ObsUI::CreateLayerInfo());
	Layers::Create("TimeDiff", ObsUI::CreateLayerTimeDiff());
	Layers::Create("Utils", ObsUI::CreateLayerUtilities());
	Layers::Create("Markers");
	Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
	Layers::Create("Items", Items::CreateLayerItems());
	Layers::Create("Records", RecordsUI::CreateManialink(S_RecordsWidgetTitle));
	
	Layers::Attach("Info");
	Layers::Attach("TimeDiff");
	Layers::Attach("Utils");
	Layers::Attach("Markers");
	Layers::Attach("Items");
	Layers::Attach("Records");

	CustomUI::Load();
	CustomUI::Add("CustomUI_Info", <-100., 88.>, <40., 8.>);
	CustomUI::Add("obstacle_records", <139., 40.>, <42., 80.>);
	CustomUI::Add(ObsUI::C_Module_Chrono, <50., -73.>, <40., 10.>);
	CustomUI::Add(ObsUI::C_Module_NextMapVoting, <0., 75.>, <60., 4.>);
	CustomUI::Add(ObsUI::C_Module_TimeDiff, <0., 65.>, <60., 12.>);
	CustomUI::Add(ObsUI::C_Module_CPProgress, <-47., -78.>, <40., 5.>);
	CustomUI::Add(ObsUI::C_Module_RespawnBehavior, <-50., 88.>, <50., 8.>);
	CustomUI::Add(ObsUI::C_Module_RestartLock, <45., 88.>, <50., 8.>);
	CustomUI::Add(ObsUI::C_Module_SpectateCount, <150., -63.>, <20., 8.>);
	CustomUI::Add(Items::C_Module_Items, <0., -65.>, <80., 40.>);
	CustomUI::Add(Items::C_Module_ItemsInfo, <0., 40.>, <110., 10.>);
	CustomUI::Build();
}