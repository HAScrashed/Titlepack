#Extends "Modes/ShootMania/Base/CustomBase.Script.txt"

#Const CompatibleMapTypes       "ObstacleArena,ObstacleTitleArena,ObstacleTitleArenaOld,TimeAttackArena,ObstacleBetaArena"
#Const  Version                         "1.3"
#Const  ScriptName                  "Modes/ShootMania/Obstacle.Script.txt"

// ---------------------------------- //
// Libraries
// ---------------------------------- //
#Include "TextLib" as TL
#Include "MathLib" as ML

#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Spectators.Script.txt" as Spectators
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/Scores.Script.txt" as Scores
#Include "Libs/Nadeo/ShootMania/SM3.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen

#Include "Libs/smokegun/Player.Script.txt" as Player
#Include "Libs/smokegun/ObstacleLib.Script.txt" as Obstacle

#Include "Libs/smokegun/UI.Script.txt" as ObsUI

#Include "Libs/smokegun/UI/Markers.Script.txt" as UI_Markers
#Include "Libs/smokegun/UI/RecordsWidget.Script.txt" as RecordsWidget
#Include "Libs/smokegun/Items.Script.txt" as Items
#Include "Libs/smokegun/ObstacleRecords.Script.txt" as API
#Include "Libs/smokegun/Weapons.Script.txt" as Weapons

#Include "Libs/smokegun/CPTimes.Script.txt" as CPTimes


// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeLimit 30 as _("Time limit")
#Setting S_PvPWeapons           False   as _("Enable PvP Weapons")
#Setting S_FullAmmoSpawn            True    as _("Spawning with full Ammunition")
#Setting S_FastRespawn          True    as _("Fast respawn on the checkpoint")
#Setting S_AllowJump    True as _("Enable checkpoint jumping")
#Setting S_LegacyRespawn    False as _("LEGACY: Enable old respawn")

#Setting S_RecordsPerTick   100 as "<hidden>"
#Setting S_RecordsTickDelay 50 as "<hidden>"
#Setting S_NextMapVotingRatio   0.7     as "<hidden>"

#Setting S_ScriptEnvironment "development"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_HudModulePath "Obstacle/UI.Module.Gbx" ///< Path to the hud module
#Const Description _("Finish map as fast as possible !")
#Const C_DefaultTimeLimit 30

***MB_Private_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
***

***MB_Private_Settings***
***
MB_Settings_UseDefaultHud = False;
MB_Settings_UseDefaultTimer = False;

UsePvPCollisions = False;
UseClans = False;
UseSameWallJump = True;
UsePvPWeapons = S_PvPWeapons;

UIManager.UIAll.OverlayHide321Go = False;
***

***MB_Private_Rules***
***
ModeInfo::SetName("Obstacle");
ModeInfo::SetType(ModeInfo::Type_FreeForAll());

declare OpenSpecial1Text = "$<$00f";
    declare OpenSpecial2Text = "$<$88f";
    declare OpenSpecial3Text = "$<$0f0";
    declare OpenSpecial4Text = "$<$f80";
    declare OpenBoldText = "$<$o";
    declare OpenSettingText = "$<$08f";
    declare CloseText = "$>";

    declare ModeRules = """
Finish the {{{OpenSpecial2Text}}}Obstacle Course{{{CloseText}}} as fast as possible.
To validate a race you must touch the {{{OpenSpecial2Text}}}Goal{{{CloseText}}} after going through all the {{{OpenSpecial2Text}}}Checkpoints{{{CloseText}}}.
You can start over and improve your time as often as you want during {{{OpenSettingText^S_TimeLimit^CloseText}}} minutes.
The player with the best time wins the map.
Press the {{{OpenBoldText}}}Respawn{{{CloseText}}} button (default: {{{OpenSpecial2Text}}}Backspace{{{CloseText}}}) or die to {{{OpenSpecial3Text}}}Respawn{{{CloseText}}} at the last reached checkpoint.
Press the {{{OpenBoldText}}}Give Up{{{CloseText}}} button (default: {{{OpenSpecial2Text}}}Delete{{{CloseText}}}) to {{{OpenSpecial3Text}}}Restart{{{CloseText}}} from the beginning.

Press {{{OpenSpecial4Text}}}F3{{{CloseText}}} when you're ready for the next Map (Press F3 again to change your decision).
Press {{{OpenSpecial4Text}}}F4{{{CloseText}}} to disable/enable respawning at checkpoints.
Press {{{OpenSpecial4Text}}}F5{{{CloseText}}} to disable/enable respawning from the start.
""";


ModeInfo::SetRules(ModeRules);
ModeInfo::SetStatusMessage(_("Finish the map as fast as possible."));
***

***MB_Private_LoadHud***
***
Hud_Load(C_HudModulePath);
if (Hud != Null && Hud.ScoresTable != Null) {
    Hud.ScoresTable.Scores_Sort(CModulePlaygroundScoresTable::EScoreSortOrder::SMPoints);

    Tabs::Load();
    declare TabsLayer <=> Tabs::CreateTabPaneLayer(
        [ "ScoresTab" => "Rankings"
        , "CPTimes" => "Race"
        ], 15, 7, False);
    TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
    UIManager.UIAll.UILayers.add(TabsLayer);
}
***

***MB_Private_SpawnScreen***
***
SpawnScreen::CreateScores("Score.Points");
***

***InitServer***
***
declare Integer G_LastUpdate = 0;
***

***MB_Private_StartServer***
***
+++LoadHud+++
SM::SetupDefaultVisibility();

Spectators::ForceCamera(Spectators::Camera_FirstPerson());
ObsUI::SetNextMapVotingRatio(S_NextMapVotingRatio);
Items::Init();
CreateUI();
API::Init(S_RecordsPerTick, S_RecordsTickDelay);
***

***MB_Private_InitMap***
***
declare Integer PrevTimeLimit = -1;
declare Boolean PrevPvPWeapons = S_PvPWeapons;
declare LastUpdate = -1;
***

***MB_Private_StartMap***
***
// map is invalid
if(!Obstacle::PrepareMap())
{
    MB_Private_StopMap();
}

UIManager.UIAll.MarkersXML = UI_Markers::GetMarkersXML();
Layers::Update("Markers", UI_Markers::GetMarkersFrames());

API::StartMap(S_RecordsPerTick, S_RecordsTickDelay);

Obstacle::SetSettings(S_FullAmmoSpawn, S_FastRespawn, S_LegacyRespawn, S_AllowJump);
Items::Place();

foreach(Player in AllPlayers) {
    Player::setInitialized(Player, False);
    Obstacle::NewPlayer(Player);
}

StartTime = Now;
if (S_TimeLimit > 0) {
    EndTime = (StartTime + S_TimeLimit * 1000 * 60);
} else {
    EndTime = (StartTime + C_DefaultTimeLimit * 1000 * 60);
}
***

***MB_Private_PlayLoop***
***

API::Loop();

if (Now > EndTime) {
    Message::SendBigMessage(_("Time limit reached"),    2000, 3, CUIConfig::EUISound::Silence, 0);
    MB_Private_StopMatch();
}

foreach(Event in UIManager.PendingEvents) {
    if(Event.Type == CUIConfigEvent::EType::OnLayerCustomEvent) {
        switch(Event.CustomEventType) {
            case "jump_request": {
                declare Player = SM::GetPlayer(Event.CustomEventData[0]);
                declare CP = TL::ToInteger(Event.CustomEventData[1]);
                Obstacle::JumpToCheckpoint(Player, CP);
            }
        }
    }
}

foreach (Event in PendingEvents) {
    switch (Event.Type) {

        case CSmModeEvent::EType::OnArmorEmpty: {
            // Discard the defaut behaviour (e.g Player is eliminated)
            Discard(Event);

            // Dont respawn if the player has the offzone item
            if (Event.Victim.IsInOffZone) {
                declare ItemBuffs = Player::getBuffTimes(Event.Victim);
                if (ItemBuffs.existskey(Items::T_ItemOffzone) && ItemBuffs[Items::T_ItemOffzone] >= Now) {
                    continue;
                }
            }

            Obstacle::RespawnPlayer(Event.Victim);
        }

        case CSmModeEvent::EType::OnHit: {
            // Disable the loose of armor when hit
            Discard(Event);
        }

        case CSmModeEvent::EType::OnPlayerRequestRespawn: {
            Obstacle::RespawnPlayer(Event.Player, Event.GiveUp);
            Discard(Event);
        }

        case CSmModeEvent::EType::OnPlayerTouchesObject: {
            if (Event.Object != Null && Event.Player != Null && Items::PickupItems(Event)) {
                PassOn(Event);
            }
            else {
                Discard(Event);
            }
        }

        case CSmModeEvent::EType::OnPlayerTriggersSector: {
            Obstacle::HandleCapture(Event.Player);
        }

        default: {
            PassOn(Event);
        }

    }
}

foreach (Player in Players) {
    switch (Player.SpawnStatus) {

        case CSmPlayer::ESpawnStatus::NotSpawned: {
            if(!Player::isInitialized(Player))
                Obstacle::NewPlayer(Player);

            if (!Player.RequestsSpectate) {
                Obstacle::RespawnPlayer(Player);
            }
        }

        case CSmPlayer::ESpawnStatus::Spawned: {
            // Unlimited stam
            declare StaminaUnlimited for Player = False;
            if(StaminaUnlimited && Player.Stamina < 7500) {
                Player.Stamina = 10800;
            }

            // Effects on respawn
            declare PlayerHasRespawned for Player = False;
            if(PlayerHasRespawned) {
                if(S_FullAmmoSpawn) {
                    Weapons::FillUpPlayerAmmo(Player);
                }

                PlayerHasRespawned = False;
            }

            // Manage item effects
            declare ItemBuff = Player::getBuffTimes(Player);
            foreach (Name => Time in ItemBuff) {
                if (Time < Now) continue;
                switch (Name) {
                    // Progressively grant ammo
                    case Items::T_ItemAmmo: {
                        declare AmmoItemBuffDuration for Player = 0.;
                        if (AmmoItemBuffDuration <= 0.) continue;
                        declare AmmoItemBuffAmount for Player = 1.;
                        declare TickAmount = AmmoItemBuffAmount / (AmmoItemBuffDuration * 1000. / Period);
                        AddPlayerAmmo(Player, SM::GetWeapon(Player.CurWeapon), TickAmount);
                    }
                }
            }
        }

    }
}

// Update settings at runtime
if (PrevTimeLimit != S_TimeLimit) {
    PrevTimeLimit = S_TimeLimit;

  if (Hud != Null && Hud.ScoresTable != Null) {
    Hud.ScoresTable.SetFooterText(TL::Compose("%1 "^TL::TimeToText(S_TimeLimit * 60 * 1000), _("Time limit : ")));
  }

    if (S_TimeLimit > 0) {
        EndTime = StartTime + (S_TimeLimit * 60 * 1000);
    } else {
        EndTime = StartTime + (C_DefaultTimeLimit * 60 * 1000);
    }
}

if (PrevPvPWeapons != S_PvPWeapons) {
    PrevPvPWeapons = S_PvPWeapons;
    UsePvPWeapons = S_PvPWeapons;
}

if (LastUpdate + 1000 < Now) {
    LastUpdate = Now;

    ObsUI::UpdateLayerUtilities();
    Obstacle::SetSettings(S_FullAmmoSpawn, S_FastRespawn, S_LegacyRespawn, S_AllowJump);
}
***


***MB_Private_EndMap***
***
Items::Destroy();
EndTime = -1;

UIManager.UIAll.MarkersXML = "";
SM::UnspawnAllPlayers();

declare BestPlayerScore <=> Scores::GetBestPlayerMapPoints(Scores::C_Order_Descending);
if (BestPlayerScore != Null) {
    Scores::SetPlayerWinner(BestPlayerScore);
} else {
    Scores::ResetPlayerWinner();
}
***

***MB_Private_BeforeCloseLadder***
***
declare Unranked = CSmScore[];

declare WorstRun = -1;
foreach (Score in Scores) {
    declare BestRun for Score = 1;
    if (BestRun > 0) {
        Score.LadderRankSortValue = BestRun;

        if(BestRun > WorstRun) WorstRun = BestRun;
    }
    else {
        Unranked.add(Score);
    }
}

foreach(Score in Unranked) {
    Score.LadderRankSortValue = WorstRun + 1;
}
***

***MB_Private_AfterCloseLadder***
***
DoNothing();
***

***MB_Private_EndServer***
***
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();

Layers::Detach("Info");
Layers::Detach("TimeDiff");
Layers::Detach("Utils");
Layers::Detach("Markers");
Layers::Detach("Items");
Layers::Detach("Records");
UIManager.UILayerDestroyAll();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //
// ---------------------------------- //
Void DoNothing(){}

Void CreateUI() {
    Layers::Create("Info", ObsUI::CreateLayerInfo());
    Layers::Create("TimeDiff", ObsUI::CreateLayerTimeDiff());
    Layers::Create("Utils", ObsUI::CreateLayerUtilities());
    Layers::Create("Markers");
    Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
    Layers::Create("Items", Items::CreateLayerItems());
    Layers::Create("Records", RecordsWidget::CreateManialink());
    Layers::Create("CPTimes", CPTimes::CreateManialink());

    Layers::Attach("Info");
    Layers::Attach("TimeDiff");
    Layers::Attach("Utils");
    Layers::Attach("Markers");
    Layers::Attach("Items");
    Layers::Attach("Records");
    Layers::Attach("CPTimes");

    CustomUI::Load();
    CustomUI::Add("CustomUI_Info", <-100., 88.>, <40., 8.>);
    CustomUI::Add("Frame_Small_Records", <139., 75.>, <44., 67.>, "top", "center");
    CustomUI::Add(ObsUI::C_Module_Chrono, <50., -73.>, <40., 10.>);
    CustomUI::Add(ObsUI::C_Module_NextMapVoting, <0., 75.>, <60., 4.>);
    CustomUI::Add(ObsUI::C_Module_TimeDiff, <0., 65.>, <60., 12.>);
    CustomUI::Add(ObsUI::C_Module_CPProgress, <-47., -78.>, <40., 5.>);
    CustomUI::Add(ObsUI::C_Module_RespawnBehavior, <-50., 88.>, <50., 8.>);
    CustomUI::Add(ObsUI::C_Module_RestartLock, <45., 88.>, <50., 8.>);
    CustomUI::Add(ObsUI::C_Module_SpectateCount, <150., -63.>, <20., 8.>);
    CustomUI::Add(Items::C_Module_Items, <0., -65.>, <80., 40.>);
    CustomUI::Add(Items::C_Module_ItemsInfo, <0., 40.>, <110., 10.>);
    CustomUI::Build();
}
