/*********************************************
* Obstacle Library                           *
* Author:  smokegun                          *
*                                            *
* Obstacle functions.                        *
*********************************************/

#Include "TextLib" as TL
#Include "Libs/smokegun/RecordsUI.Script.txt" as RecordsUI
#Include "Libs/smokegun/Record.Script.txt" as RecordUtils
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/Nadeo/Json2.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/SM3.Script.txt" as SM

/*********************************************
 CONSTANTS
*********************************************/
#Const Version "2017-07-28"
#Const ScriptName "ObstacleRecords.Script.txt"


#Const C_HostUrl "http://localhost:3000/api/"
//#Const C_HostUrl "https://api.obstacle.ovh/api/"


#Const C_SIdle 0
#Const C_SLoggingIn 1
#Const C_SParsingRecords 2
#Const C_SCountingRecords 3
#Const C_SReceivingRecords 4


/*********************************************
  GLOBALES
*********************************************/
// Settings
declare Integer G_RecordsPerTick;
declare Integer G_RecordsTickDelay;

// General globals
declare Text G_Token;
declare Text G_PostHeaders;
declare Text G_GetHeaders;
declare Text G_TokenSuffix;
declare Integer G_HostUrlLength;

// Login
declare Ident G_LoginRequestId;
declare Boolean G_IsLoggedIn;
declare Integer G_LastRequestAttempt;

// Requests
declare Text[] G_ToPost_Url;
declare Text[] G_ToPost_Data;
declare Text[Ident] G_CurrRequest;

// Records
declare Integer G_LastParsingAttempt;
declare Ident G_GetRequestId;
declare Integer G_RecordsCount;
declare Text[][] G_Records;

// State (what the lib is doing)
declare Integer G_State;
declare Integer G_PreviousState;

/////////////////////////////////////////////////////////////////
/////////////////////       TOOLS       /////////////////////////
/////////////////////////////////////////////////////////////////

Text State(Integer _State) {
    switch(_State) {
        case 0:
            return "Idle";
        case 1:
            return "Logging in";
        case 2:
            return "Parsing Records";
        case 3:
            return "Couting Records";
        case 4:
            return "Receiving Records";
    }
    return "unknow";
}

Boolean Contains(Text _Text, Text _Input) {
    return TL::Find(_Text, _Input, False, False);
}

// Used to create a POST request
Ident MakePost(Text _Url, Text _Data) {
    G_LastRequestAttempt = Now;

    if(Http.Requests.count >= Http.SlotsAvailable) {
        return NullId;
    }

    declare request <=> Http.CreatePost(C_HostUrl^_Url, _Data, G_PostHeaders);
    return request.Id;
}

Void SendPost(Text _Url, Text _Data) {
    if(!G_IsLoggedIn || G_LastRequestAttempt + 500 > Now) {
        Log::Log("Cant do req now "^_Url);
        G_ToPost_Url.add(_Url);
        G_ToPost_Data.add(_Data);
    } else {
        Log::Log("Send req "^_Url);
        G_CurrRequest[MakePost(_Url, _Data)] = _Data;
    }
}

/////////////////////////////////////////////////////////////////
/////////////////////   MAIN FUNCTIONS  /////////////////////////
/////////////////////////////////////////////////////////////////

Void Login() {
    // Destroy previous login request
    if(G_LoginRequestId != NullId && Http.Requests.existskey(G_LoginRequestId)) {
        Http.Destroy(Http.Requests[G_LoginRequestId]);
    }

    // Get the first line of the file
    declare payload = """
    {
    "username": "username",
    "password": "password"
    }""";

    G_LoginRequestId = MakePost("Users/Login", payload);
    G_State = C_SLoggingIn;
}

Void StartMap(Integer _RecordsPerTick, Integer _RecordsTickDelay) {
    G_RecordsPerTick = _RecordsPerTick;
    G_RecordsTickDelay = _RecordsTickDelay;
}

// Init the API with a token
Void Init(Integer _RecordsPerTick, Integer _RecordsTickDelay) {
    G_PostHeaders = """Content-Type: application/json
    Accept: application/xml""";
    G_GetHeaders = """Accept: application/xml""";
    G_HostUrlLength = TL::Length(C_HostUrl);

    StartMap(_RecordsPerTick, _RecordsTickDelay);
    Login();
}

/////////////////////////////////////////////////////////////////
/////////////////////      RECORDS      /////////////////////////
/////////////////////////////////////////////////////////////////

Void UpdateRecords() {
    if(G_GetRequestId != NullId && Http.Requests.existskey(G_GetRequestId)) {
        Http.Destroy(Http.Requests[G_GetRequestId]);
    }
    G_State = C_SCountingRecords;
    declare request <=> Http.CreateGet(C_HostUrl^"""Records/count?where={"mapId":"{{{Map.Id}}}"}""", False, G_GetHeaders);

    G_GetRequestId = request.Id;
}

Void StartParsingRecords() {
    if(G_GetRequestId == NullId ||
    !Http.Requests.existskey(G_GetRequestId) ||
    Http.Requests[G_GetRequestId].IsCompleted)
    {
        G_State = C_SReceivingRecords;
        declare skip = G_Records.count;
        declare request <=> Http.CreateGet(C_HostUrl^"Records/with-player?mapId="^Map.Id^"&limit="^G_RecordsPerTick^"&skip="^skip, False, G_GetHeaders);

        G_GetRequestId = request.Id;
    }
}

Void StartReceiveRecords(Text _CountResponse) {
    G_Records.clear();
    declare XmlRecords = Xml.Create(_CountResponse);
    G_RecordsCount = TL::ToInteger(XmlRecords.Root.Children[0].TextContents);
    Xml.Destroy(XmlRecords);
    StartParsingRecords();
}

Void ParseRecords(Text _RecordsAsText) {
    G_State = C_SParsingRecords;

    declare XmlRecords = Xml.Create(_RecordsAsText);

    foreach(Idx => Record in XmlRecords.Root.Children) {
        declare Text[] ToAdd;
        ToAdd.add(RecordUtils::GetPlayerField(Record, "login"));
        ToAdd.add(RecordUtils::GetPlayerField(Record, "nickname"));
        ToAdd.add(RecordUtils::GetTime(Record));
        ToAdd.add(RecordUtils::GetField(Record, "respawnCount"));
        ToAdd.add(RecordUtils::GetField(Record, "tryCount"));
        G_Records.add(ToAdd);
    }
    Xml.Destroy(XmlRecords);

    RecordsUI::Refresh(G_Records);
    Log::Log("Endparse ("^G_Records.count^"|"^G_RecordsCount^")");

    if(G_Records.count < G_RecordsCount) {
        StartParsingRecords();
    } else {
        G_State = C_SIdle;
    }
}

/////////////////////////////////////////////////////////////////
/////////////////////  API FUNCTIONS    /////////////////////////
/////////////////////////////////////////////////////////////////

// Send map infos
Void ReplaceOrCreateMap() {
    declare payload = """
    {
    "name": {{{Json::GetText(Map.MapName)}}},
    "maniaplanetMapId": {{{Json::GetText(""^Map.Id)}}},
    "playerId": {{{Json::GetText(Map.AuthorLogin)}}}
    }
    """;

    SendPost("Maps/replaceOrCreate", payload);
}

// Update player infos
Void ReplaceOrCreatePlayer(CSmPlayer _Player) {
    declare payload = """
    {
    "login": {{{Json::GetText(_Player.User.Login)}}},
    "nickname": {{{Json::GetText(_Player.User.Name)}}}
    }""";

    SendPost("Players/replaceOrCreate", payload);
}

// Send records
Void PlayerFinished(CSmPlayer _Player) {
    declare LastRun for _Player.Score = -1;
    declare RespawnCount for _Player.Score = 0;
    declare payload = """
    {
    "time": {{{LastRun}}},
    "respawnCount": {{{Json::GetInteger(RespawnCount)}}},
    "playerId": {{{Json::GetText(_Player.User.Login)}}},
    "mapId": {{{Json::GetText(""^Map.Id)}}}
    }""";

    SendPost("Records/player-finished", payload);
}


/////////////////////////////////////////////////////////////////
/////////////////////      LOOP         /////////////////////////
/////////////////////////////////////////////////////////////////

Void Loop() {

    if(G_PreviousState != G_State) {
        Log::Log(State(G_PreviousState)^" ===> "^State(G_State));
        G_PreviousState = G_State;
    }

    if(G_IsLoggedIn) {
        /*
        /** REQUESTS PROCESSING
        */

        /*
        * G_ToPost arrays act more or less like a queue
        * We execute requests saved one by one
        */
        if(G_ToPost_Url.count > 0 && G_LastRequestAttempt + 500 < Now) {
            if(G_ToPost_Url.count != G_ToPost_Data.count) {
                Log::Error("G_ToPost_Url and G_ToPost_Data have different sizes!");
            }

            SendPost(G_ToPost_Url[0], G_ToPost_Data[0]);

            G_ToPost_Url.removekey(0);
            G_ToPost_Data.removekey(0);
        }

        /*
        * We wait for each post request's response
        */
        foreach(reqId => data in G_CurrRequest) {
            declare request <=> Http.Requests[reqId];
            if(!request.IsCompleted) continue;

            Log::Log("Request done: ("^request.StatusCode^") "^request.Url);
            Log::Log(request.Result);

            // Request failed
            if(request.StatusCode == 401) {
                G_IsLoggedIn = False;
                declare ApiUrl = TL::SubString(request.Url, G_HostUrlLength, TL::Length(request.Url) - G_HostUrlLength);
                SendPost(ApiUrl, data);

                // Request succeded
            } else {
                declare response = Xml.Create(request.Result);

                if(TL::Find("player-finished", request.Url, True, True)) {
                    declare isNewBest = response.Root.GetFirstChild("newBest").TextContents == "true";
                    // TODO: Add fields to backend response
                    declare login = response.Root.GetFirstChild("login").TextContents;
                    declare old = TL::ToInteger(response.Root.GetFirstChild("old").TextContents);
                    declare new = TL::ToInteger(response.Root.GetFirstChild("new").TextContents);

                    declare Player = SM::GetPlayer(login);
                    if(isNewBest) {
                        UIManager.UIAll.SendChat("""{{{Player.User.Name}}}$z made a new record ! ({{{TL::TimeToText(new, True)}}})""");
                    } else {
                        if(Player != Null) {
                            UIManager.GetUI(Player).SendChat("""$zAt least you tried, you were too late by {{{TL::TimeToText(new-old, True)}}} !""");
                        }
                    }
                }

                Xml.Destroy(response);
                UpdateRecords();
            }

            // Destroy requests when they are done
            G_CurrRequest.removekey(reqId);
            Http.Destroy(request);

        }

        /*
        * Wait for the records request
        */
        if(G_GetRequestId != NullId &&
        Http.Requests.existskey(G_GetRequestId) &&
        Http.Requests[G_GetRequestId].IsCompleted)
        {
            declare GetRequest <=> Http.Requests[G_GetRequestId];

            if(GetRequest.StatusCode == 200)
            {
                if(G_State == C_SCountingRecords)
                {
                    StartReceiveRecords(GetRequest.Result);

                    Http.Destroy(GetRequest);
                }
                else if (G_State == C_SReceivingRecords && G_LastParsingAttempt + G_RecordsTickDelay < Now)
                {
                    G_LastParsingAttempt = Now;
                    ParseRecords(GetRequest.Result);

                    Http.Destroy(GetRequest);
                }
            }
        }

    }
    else
    {
        /*
        * Wait for the login request to finish
        */
        if(G_State == C_SLoggingIn && Http.Requests.existskey(G_LoginRequestId))
        {
            declare LoginRequest <=> Http.Requests[G_LoginRequestId];

            if(LoginRequest.IsCompleted)
            {
                if(LoginRequest.StatusCode == 200)
                {
                    Log::Log("Logged in: ("^LoginRequest.StatusCode^") "^LoginRequest.Result);
                    declare XmlResponse = Xml.Create(LoginRequest.Result);
                    G_Token = XmlResponse.Root.GetFirstChild("id").TextContents;
                    Xml.Destroy(XmlResponse);
                    G_IsLoggedIn = True;
                    G_PostHeaders = G_PostHeaders^"""
                    Authorization: {{{G_Token}}}""";
                }

                // We are done logging in
                G_State = C_SIdle;
            }
        }
        // We're not logged in and doing nothing so try to reconnect
        else if(G_LastRequestAttempt + 1000 < Now)
        {
            Login();
        }
    }
}
