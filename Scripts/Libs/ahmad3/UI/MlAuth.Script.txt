/************************************************
 *   Obstacle Library                            *
 *   Author:     ahmad3                          *
 *                                               *
 *   Util functions for auth system              *
 ************************************************/

#Include "MathLib" as MathLib
#Include "TimeLib" as TimeLib
#Include "Libs/smokegun/Constants.Script.txt" as Constants
#Include "Libs/miltant/RunFlags.Script.txt" as RunFlags
#Include "Libs/ahmad3/Utils.Script.txt" as Utils

#Include "Libs/ahmad3/Error.Script.txt" as Error
#Include "Libs/ahmad3/Ban.Script.txt" as Ban

/*********************************************
  CONSTANTS
 *********************************************/

#Const  Version     "2023-08-02"
#Const  ScriptName  "MlAuth.Script.txt"

#Const C_AuthMessage """We are about to refresh your personal tokens.

This procedure will open your browser to the ManiaPlanet's login page.
You will only have to authenticate with the same account as the one
you use in game."""

#Const C_AuthMessage_UpdatePlayer """Hey there! To continue to enjoy Obstacle,
we need you to authenticate with your ManiaPlanet account.
"""

#Const C_AuthMessage_PlayerFinished """Hey! Before you finish and save your record,
we need you to authenticate with your ManiaPlanet account.
Do not skip this step, or your run will be lost! Don't worry, it's fast!
"""

#Const C_Security_OpenplanetDevMsg """It looks like you have Openplanet with developer mode enabled.
This may offer you a number of features that could be contrary to fair play.
It is why we do not authorize it in our mode.

Please disable the developer mode for the plugins signature.

If you think this is an error, please mention the developers
(i.e. @miltant or @ahmadbky) on Discord.

Thank you.
"""

#Const C_ErrMessage """An error occurred. This may be due to many reasons,
but to help the developers to find out a solution, please open the
console window with Ctrl+G. You can also try to quit and join a server
or play any local map.
"""

#Const C_MaintenanceMessage """The Obstacle API is currently in Maintenance mode.
If you make a record on this map, your run will not be saved
immediately.

If everything goes right, your time will appear after the maintenance,
but to be sure, ping @ahmadbky on the Obstacle discord with
a screenshot of your run.

Sorry for the inconvenience.
"""

Text GetLayer() {
	return """
<manialink version="3" name="Obstacle:Auth">
<frame id="Frame_AuthDialog" hidden="1">
	<frame z-index="1000" pos="0 0">
		<quad z-index="-1" size="100 75" style="Bgs1" substyle="BgButtonOff" halign="center" valign="center" />
		<label pos="0 35" size="40 5" text="Authentication" style="TextTitle3" textsize="4" halign="center" textfont="OswaldMono" maxline="1" valign="top" textemboss="1"/>

		<frame pos="-48 14">
			<label id="AuthDialog_HeadMsg" size="96 4" halign="left" valign="center" textsize="1.4" />
		</frame>

		<frame pos="-48 0">
			<label id="AuthDialog_Msg" size="96 4" halign="left" valign="center" textsize="1.4" text={{{dump(C_AuthMessage)}}} />
		</frame>

		<frame id="Frame_AuthDialog_Button" pos="0 -35">
			<label pos="0 1" size="15 6" text="Fine!" valign="bottom" halign="center" textfont="regular" textsize="2.1" textcolor="fff" />
			<quad
			 	id="Frame_AuthDialog_Button_OK"
				scriptevents="1"
				valign="bottom"
				halign="center"
				size="15 6"
				image="file://Media/Images/Obstacle/Dialogs/BDefault21.png"
			/>
		</frame>
	</frame>
</frame>
<frame id="Frame_Security_OpenplanetDev" hidden="1">
	<frame z-index="1000" pos="0 0">
		<quad z-index="-1" size="100 75" style="Bgs1" substyle="BgButtonOff" halign="center" valign="center" />
		<label pos="0 35" size="40 5" text="Warning" style="TextTitle3" textsize="4" halign="center" textfont="OswaldMono" maxline="1" valign="top" textemboss="1"/>

		<frame pos="-48 14">
			<label id="Security_Msg" size="96 4" halign="left" valign="center" textsize="1.4" text={{{dump(C_Security_OpenplanetDevMsg)}}} />
		</frame>
	</frame>
</frame>
<frame id="Frame_ErrDialog" hidden="1">
	<frame z-index="1000" pos="0 0">
		<quad z-index="-1" size="100 75" style="Bgs1" substyle="BgButtonOff" halign="center" valign="center" />
		<label pos="0 35" size="40 5" text="Error" style="TextTitle3" textsize="4" halign="center" textfont="OswaldMono" maxline="1" valign="top" textemboss="1"/>

		<label id="ErrDialog_HeadMsg" size="96 5" halign="left" valign="center" pos="-48 4" textsize="1.4" text={{{dump(C_ErrMessage)}}} />

		<frame id="Frame_ErrDialog_Button" pos="0 -35">
			<label pos="0 1" size="15 6" text="OK :(" valign="bottom" halign="center" textfont="regular" textsize="2.1" textcolor="fff" />
			<quad
			 	id="Frame_ErrDialog_Button_OK"
				scriptevents="1"
				valign="bottom"
				halign="center"
				size="15 6"
				image="file://Media/Images/Obstacle/Dialogs/BDefault21.png"
			/>
		</frame>
	</frame>
</frame>
<frame id="Frame_MaintenanceDialog" hidden="1">
	<frame z-index="1000" pos="0 0">
		<quad z-index="-1" size="100 75" style="Bgs1" substyle="BgButtonOff" halign="center" valign="center" />
		<label pos="0 35" size="40 5" text="API maintenance" style="TextTitle3" textsize="4" halign="center" textfont="OswaldMono" maxline="1" valign="top" textemboss="1"/>

		<label id="MaintenanceDialog_HeadMsg" size="96 5" halign="left" valign="center" pos="-48 12.5" textsize="1.4" text={{{dump(C_MaintenanceMessage)}}} />

		<frame id="Frame_MaintenanceDialog_Button" pos="0 -35">
			<label pos="0 1" size="20 6" text="Play anyway" valign="bottom" halign="center" textfont="regular" textsize="2.1" textcolor="fff" />
			<quad
			 	id="Frame_MaintenanceDialog_Button_OK"
				scriptevents="1"
				valign="bottom"
				halign="center"
				size="21 6"
				image="file://Media/Images/Obstacle/Dialogs/BDefault21.png"
			/>
		</frame>
	</frame>
</frame>
<script><!--

#Include "MathLib" as MathLib
#Include "TimeLib" as TimeLib
#Include "TextLib" as TL

#Const C_AuthMessage_UpdatePlayer {{{dump(dump(dump(C_AuthMessage_UpdatePlayer)))}}}
#Const C_AuthMessage_PlayerFinished {{{dump(dump(dump(C_AuthMessage_PlayerFinished)))}}}

#Struct K_GetTokenBody {
	Text login;
	Text state;
	Text redirect_uri;
}

#Struct K_GetTokenResponse {
	Text token;
}

#Struct SRequestData {
    Text Headers;
    Text Url;
    Text Data;
}

#Struct K_UpdatePlayerBody {
    Text login;
    Text name;
    Text zone_path;
}

#Struct K_HasFinishedBody {
    Integer time;
    Integer respawn_count;
    Text login;
    Text map_uid;
    Integer flags;
    Integer[] cps;
}

#Struct K_ReportErrorBody {
	Text on_route;
	Text request_id;
	Text map_uid;
	Integer err_type;
	Text err_msg;
	Integer time;
	Integer respawn_count;
}

/**
 * A staggered request.
 *
 * This is used to store the failed requests in a cache to send them later.
 */
#Struct K_StaggeredReq {
	/**
	 * The API route segment of the request.
	 */
	Text Route;
	/**
	 * The request timestamp.
	 */
	Integer Tstp;
	/**
	 * The request JSON body.
	 */
	Text Body;
}

{{{Ban::ML_Preproc()}}}
{{{Error::ML_Preproc()}}}
{{{RunFlags::ML_Preproc()}}}

{{{Ban::ML_Content()}}}
{{{Error::ML_Content()}}}
{{{RunFlags::ML_FlagSum()}}}
{{{Utils::ML_FindCharIndex("Utils_", "TL")}}}

declare Boolean G_Errored;

declare CMlFrame	G_AuthDialog;
declare CMlQuad		G_AuthDialog_Submit;
declare CMlLabel	G_AuthDialog_HeadMsg;

declare CMlFrame	G_SecurityFrame;

// Error frames
declare CMlFrame	G_ErrDialog;
declare CMlQuad		G_ErrDialog_Submit;

// Maintenance frames
declare CMlFrame	G_MaintenanceDialog;
declare CMlQuad		G_MaintenanceDialog_Submit;

// Used to create a POST request
Ident MakePost(Text _Url, Text _Data) {
    if (Http.SlotsAvailable > 0) {
        log(" Sending request to "^_Url);
        log(" Payload: "^_Data);
		declare persistent ObsStore_UserToken for LocalUser = "";
        declare request <=> Http.CreatePost({{{dump(Constants::C_HostUrl)}}}^_Url, _Data, "Content-Type: application/json\nAccept: application_json\nPlayerLogin: " ^ InputPlayer.User.Login ^ "\nAuthorization: " ^ ObsStore_UserToken);
        return request.Id;
    }
    return NullId;
}

Boolean _OnPopup_CannotShow(CMlFrame _Frame) {
	declare Boolean __MlAuth_EndScreenVisible for LocalUser = False;
	declare Boolean EndScreen = __MlAuth_EndScreenVisible;
	// Turn it back to false
	__MlAuth_EndScreenVisible = False;
	return _Frame.Visible || EndScreen;
}

Void OnPopup(CMlFrame _Frame, CMlQuad _SubmitButton) {
	// The popup is already shown for another reason
	if (_OnPopup_CannotShow(_Frame)) {
		return;
	}
	ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
	_Frame.Show();	

	declare hovering = False;

	declare prompting = True;
	while (prompting) {
		yield;
		foreach (Event in PendingEvents) {
			switch (Event.Type) {
				case CMlScriptEvent::Type::MouseClick: {
					if (Event.Control == _SubmitButton) {
						prompting = False;
						break;
					}
				}
				case CMlScriptEvent::Type::MouseOver: {
					if (hovering) continue;
					hovering = True;
					_SubmitButton.ChangeImageUrl("file://Media/Images/Obstacle/Dialogs/BActive21.png");
				}
				case CMlScriptEvent::Type::MouseOut: {
					if (!hovering) continue;
					hovering = False;
					_SubmitButton.ChangeImageUrl("file://Media/Images/Obstacle/Dialogs/BDefault21.png");
				}
			}
		}
	}

	_Frame.Hide();
	ClientUI.UISequence = CUIConfig::EUISequence::None;
}

Void OnError(K_Error _Error, Text _OnRoute) {
	if (_Error.err.type == C_Err_Maintenance) {
		OnPopup(G_MaintenanceDialog, G_MaintenanceDialog_Submit);
		if (_OnRoute != "/player/finished") return;
	} else {
		OnPopup(G_ErrDialog, G_ErrDialog_Submit);
	}

    declare netread _LastRun for UI = -1;
    declare netread _RespawnCount for UI = 0;

	declare Body = K_ReportErrorBody {
		on_route = _OnRoute,
		request_id = _Error.err.request_id,
		map_uid = "" ^ Map.Id,
		err_type = _Error.err.type,
		err_msg = _Error.err.message,
		time = _LastRun,
		respawn_count = _RespawnCount
	};
	
	MakePost("player/report_error", Body.tojson());
}

Void Private_UpdateToken(Text _HeadMsg) {
	log("Updating token...");

	ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
	G_AuthDialog_HeadMsg.SetText(_HeadMsg);
	G_AuthDialog.Show();

	declare hovering = False;

	declare prompting = True;
	while (prompting) {
		yield;
		foreach (Event in PendingEvents) {
			switch (Event.Type) {
				case CMlScriptEvent::Type::MouseClick: {
					if (Event.Control == G_AuthDialog_Submit) {
						prompting = False;
						break;
					}
				}
				case CMlScriptEvent::Type::MouseOver: {
					if (hovering) continue;
					hovering = True;
					G_AuthDialog_Submit.ChangeImageUrl("file://Media/Images/Obstacle/Dialogs/BActive21.png");
				}
				case CMlScriptEvent::Type::MouseOut: {
					if (!hovering) continue;
					hovering = False;
					G_AuthDialog_Submit.ChangeImageUrl("file://Media/Images/Obstacle/Dialogs/BDefault21.png");
				}
			}
		}
	}

	G_AuthDialog.Hide();
	ClientUI.UISequence = CUIConfig::EUISequence::None;

	declare persistent Text ObsStore_UserToken for LocalUser;
	
	declare login = LocalUser.Login;
	declare Text state = login ^ Now;
	declare body = K_GetTokenBody {
		login = login,
		state = state,
		redirect_uri = {{{dump(Constants::C_MP_Redirect)}}}
	};
	
	declare Req = MakePost("player/get_token", body.tojson());
	if (Req == NullId) {
		log("Could not send request to server");
		G_Errored = True;
		return;
	}

	declare req <=> Http.Requests[Req];

	OpenLink({{{dump(Constants::C_MP_Link)}}}
		^ "client_id=" ^ {{{dump(Constants::C_MP_App_Id)}}}
		^ "&redirect_uri=" ^ {{{dump(Constants::C_MP_Redirect)}}}
		^ "&state=" ^ state
		^ "&scope=basic",
		CMlScript::LinkType::ExternalBrowser);
	
	wait(req.IsCompleted);
	if (req.StatusCode != 200) {
		declare err = Error_Handle(req.StatusCode, req.Result);
		UI.SendChat(err.err.message);
		OnError(err, "/player/get_token");
		G_Errored = True;
		return;
	}
	
	declare K_GetTokenResponse response;
	response.fromjson(req.Result);
	ObsStore_UserToken = response.token;
	
	log("Token updated!");
}

Boolean usedRSBug(CSmPlayer _Player) {
    declare netread Boolean Net_UsedRSBug for _Player = False;
    return Net_UsedRSBug;
}

Boolean usedAltGlitch(CSmPlayer _Player) {
    declare netread Boolean Net_UsedAltGlitch for _Player = False;
    return Net_UsedAltGlitch;
}

Boolean usedPvPWeapons(CSmPlayer _Player) {
    declare netread Boolean Net_UsedPvPWeapons for _Player = False;
    return Net_UsedPvPWeapons;
}

Boolean usedPvPCollisions(CSmPlayer _Player) {
    declare netread Boolean Net_UsedPvPCollisions for _Player = False;
    return Net_UsedPvPCollisions;
}

Boolean usedSpeedHack(CSmPlayer _Player) {
    declare netread Boolean Net_UsedSpeedHack for _Player = False;
    return Net_UsedSpeedHack;
}

/**
 * Returns the stored cache of the requests of the player.
 * 
 * @return The stored staggered requests cache of the player.
 */
K_StaggeredReq[] _Staggered_GetCache() {
	declare persistent Text ObsStore_ReqCache for LocalUser;
	declare Integer VersIndex = Utils_FindCharIndex(ObsStore_ReqCache, "[");
	if (VersIndex == -1) return [];
	declare Text Version = TL::SubText(ObsStore_ReqCache, 0, VersIndex);
	declare Text ReqCache = TL::SubText(ObsStore_ReqCache, VersIndex, TL::Length(ObsStore_ReqCache) - VersIndex);
	if ("{{{Constants::C_Version_ReqCache}}}" != Version)
		return [];
	declare K_StaggeredReq[] StaggeredReqs;
	StaggeredReqs.fromjson(ReqCache);
	return StaggeredReqs;
}

/**
 * Saves the cache of the player.
 * 
 * @param _Cache The new staggered requests cache.
 */
Void _Staggered_SaveCache(K_StaggeredReq[] _Cache) {
	declare persistent Text ObsStore_ReqCache for LocalUser;
	ObsStore_ReqCache = "{{{Constants::C_Version_ReqCache}}}" ^ _Cache.tojson();
}

/**
 * Used to save the provided body to the request cache of the player.
 * 
 * @param _Body the JSON body of the request.
 * @param _Route the request route on the API.
 */
Void SaveStaggered(Text _Body, Text _Route) {
	declare K_StaggeredReq[] StaggeredReqs = _Staggered_GetCache();
	StaggeredReqs.add(K_StaggeredReq {
		Route = _Route,
		Tstp = TL::ToInteger(TimeLib::GetCurrent()),
		Body = _Body
	});
	_Staggered_SaveCache(StaggeredReqs);
}

/**
 * Tries to send the stored cache requests of the player as staggered requests.
 */
Void TrySendStaggeredReqs() {
	declare K_StaggeredReq[] StaggeredReqs = _Staggered_GetCache();
	declare K_StaggeredReq[Integer] IndexedStaggeredReqs;
	foreach (I => StagReq in StaggeredReqs) {
		IndexedStaggeredReqs[I] = StagReq;
	}

	foreach (I => StagReq in IndexedStaggeredReqs) {
		declare Text Body = "{\"req_tstp\":" ^ StagReq.Tstp ^ ",\"body\":" ^ StagReq.Body ^ "}";
		declare Ident ReqId = MakePost("staggered/" ^ StagReq.Route, Body);
		if (ReqId == NullId) continue;
		declare CHttpRequest Req <=> Http.Requests[ReqId];
		wait(Req.IsCompleted);
		if (Req.StatusCode == 200) {
			IndexedStaggeredReqs.removekey(I);
		}
	}

	StaggeredReqs = [];
	foreach (RemainingStagReq in IndexedStaggeredReqs) {
		StaggeredReqs.add(RemainingStagReq);
	}

	_Staggered_SaveCache(StaggeredReqs);

	declare Boolean StaggeredReqsLoaded for LocalUser = False;
	StaggeredReqsLoaded = True;
}

// Send records
Void Private_PlayerFinished(Integer _LastRun, Integer _RespawnCount, Integer[] _LastCpTimes) {
    declare Flags = GetFlagsSum(
        usedRSBug(InputPlayer),
        usedAltGlitch(InputPlayer),
        usedPvPWeapons(InputPlayer),
        usedPvPCollisions(InputPlayer),
        usedSpeedHack(InputPlayer)
    );

    declare state = InputPlayer.User.Login ^ Now;

    declare body = K_HasFinishedBody {
        time = _LastRun,
        respawn_count = _RespawnCount,
        login = InputPlayer.User.Login,
        map_uid = ""^Map.Id,
        flags = Flags,
        cps = _LastCpTimes
    };

	declare Text JsonBody = body.tojson();

	declare netread Text Net_EventRoutePrefix for Teams[0];
    declare Req = MakePost(Net_EventRoutePrefix ^ "player/finished", JsonBody);
	if (Req == NullId) {
		log("Could not send request to server");
		return;
	}

	declare req <=> Http.Requests[Req];

	wait (req.IsCompleted);

	if (req.StatusCode == C_HttpErr_Unauthorized && !G_Errored) {
		Private_UpdateToken(C_AuthMessage_PlayerFinished);
		return Private_PlayerFinished(_LastRun, _RespawnCount, _LastCpTimes);
	} else if (req.StatusCode != 200) {
		declare err = Error_Handle(req.StatusCode, req.Result);
		SendCustomEvent("ban:update", [InputPlayer.User.Login, err.ban.tojson()]);
		UI.SendChat(err.err.message);
		// Instead of notifying the error, we save it as staggered to be saved later.
		SaveStaggered(JsonBody, Net_EventRoutePrefix ^ "player/finished");
	} else {
		SendCustomEvent("player:finished", [req.Result]);
	}

	Http.Destroy(req);
}

// Update player infos
Void Private_UpdatePlayer() {
    declare body = K_UpdatePlayerBody {
        name = InputPlayer.User.Name,
        zone_path = InputPlayer.User.ZonePath
    };

    declare Req = MakePost("player/update", body.tojson());
	if (Req == NullId) {
		log("Could not send request to server");
		return;
	}

	declare req <=> Http.Requests[Req];
	
	wait (req.IsCompleted);

	if (req.StatusCode == C_HttpErr_Unauthorized && !G_Errored) {
		Private_UpdateToken(C_AuthMessage_UpdatePlayer);
		return Private_UpdatePlayer();
	}

	// We deliberately ignore any other error

	Http.Destroy(Http.Requests[Req]);
}

Void InitPbCpsTimes() {
	declare netread Net_RecordsUpdated for Teams[0] = -1;
	wait(Net_RecordsUpdated != -1 || InputPlayer.StartTime != -1);

	declare persistent ObsStore_UserToken for LocalUser = "";
	
	declare netread Text Net_EventRoutePrefix for Teams[0];
	declare Url = "{{{Constants::C_HostUrl}}}" ^ Net_EventRoutePrefix ^ "player/pb?map_uid="^Map.Id;
	declare Req = Http.CreateGet(Url, True, "Accept: application/json\nPlayerLogin: " ^ InputPlayer.User.Login ^ "\nAuthorization: " ^ ObsStore_UserToken);

	wait(Req.IsCompleted);

	// Ignore any error
	if (Req.StatusCode == 200) {
		SendCustomEvent("cpstimes:init", [InputPlayer.User.Login, Req.Result]);
	}

	Http.Destroy(Req);
}

// Returns true if the user has Openplanet installed
Boolean HasOpenplanet() {
	return TL::RegexFind("^Openplanet ", System.ExtraTool_Info, "").count == 1;
}

// Returns the signature mode currently used in Openplanet
Text GetOpenplanetSignatureMode() {
	declare Text[] SignatureMode = TL::RegexMatch(" \\[([A-Z]*)\\]$", System.ExtraTool_Info, "");
	if (SignatureMode.count == 2) {
		return SignatureMode[1];
	}
	return "REGULAR";
}

Boolean HasDevMode() {
	return HasOpenplanet() && GetOpenplanetSignatureMode() == "DEVMODE";
}

main() {
	Error_Init();
	declare lastTokenUpdate = -1;
	wait(InputPlayer != Null && Page != Null);

	TrySendStaggeredReqs();

	G_AuthDialog <=> (Page.GetFirstChild("Frame_AuthDialog") as CMlFrame);
	G_AuthDialog_Submit <=> (Page.GetFirstChild("Frame_AuthDialog_Button_OK") as CMlQuad);
	G_AuthDialog_HeadMsg <=> (Page.GetFirstChild("AuthDialog_HeadMsg") as CMlLabel);

	G_SecurityFrame <=> (Page.GetFirstChild("Frame_Security_OpenplanetDev") as CMlFrame);

	// Error frames
	G_ErrDialog <=> (Page.GetFirstChild("Frame_ErrDialog") as CMlFrame);
	G_ErrDialog_Submit <=> (Page.GetFirstChild("Frame_ErrDialog_Button_OK") as CMlQuad);

	// Maintenance frames
	G_MaintenanceDialog <=> (Page.GetFirstChild("Frame_MaintenanceDialog") as CMlFrame);
	G_MaintenanceDialog_Submit <=> (Page.GetFirstChild("Frame_MaintenanceDialog_Button_OK") as CMlQuad);

	if(HasDevMode()) {
		ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
		G_SecurityFrame.Show();
	}

	wait(!HasDevMode());

	if (G_SecurityFrame.Visible) {
		G_SecurityFrame.Hide();
		ClientUI.UISequence = CUIConfig::EUISequence::None;
	}

	// Waits for the map to be initialized before we start executing the script
	declare netread Text Net_MapStartTime for Teams[0];
	declare LastMapStartTime = Net_MapStartTime;
	wait(InputPlayer.StartTime != -1 || LastMapStartTime != Net_MapStartTime);

	Private_UpdatePlayer();
    declare netread _LastRun for UI = -1;
    declare netread _RespawnCount for UI = 0;
    declare netread Integer[] _LastCPTimes for UI;
    declare LastRun_Cache = _LastRun;
    declare RespawnCount_Cache = _RespawnCount;

	InitPbCpsTimes();
	
	while (True) {
		yield;

		if (HasDevMode()) {
			if (!G_SecurityFrame.Visible) {
				ClientUI.UISequence = CUIConfig::EUISequence::UIInteraction;
				G_SecurityFrame.Show();
			}
			continue;
		} else if (G_SecurityFrame.Visible) {
			G_SecurityFrame.Hide();
			ClientUI.UISequence = CUIConfig::EUISequence::None;
		}

		if (_LastRun != LastRun_Cache || _RespawnCount != RespawnCount_Cache) {
			if (_LastRun > 0) {
				Private_PlayerFinished(_LastRun, _RespawnCount, _LastCPTimes);
			}
			LastRun_Cache = _LastRun;
			RespawnCount_Cache = _RespawnCount;
		}
	}
}

--></script>
</manialink>
	""";
}