/************************************************************
*	Game Mode:	Obstacle									*
*	Author:		steeffeen									*
*	Contact:	steeffeen@team-devota.com					*
*															*
*	Finish difficult Obstacle Courses as fast as possible.	*
*	You can respawn at the last reached checkpoints.		*
************************************************************/

#Extends "Modes/ShootMania/Base/ModeBase.Script.txt"

#Const ScriptName				"Obstacle.Script.txt"
#Const Version					"2.5 (2014-12-18)"
#Const CompatibleMapTypes		"ObstacleArena,ObstacleTitleArena,TimeAttackArena"

/*********************************************
	INCLUDES
*********************************************/

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Color.Script.txt" as Color
#Include "Libs/Nadeo/CustomUI.Script.txt" as CustomUI
#Include "Libs/Nadeo/Json.Script.txt" as Json
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/steeffeen/CheckpointTimes.Script.txt" as CPTimes
#Include "Libs/steeffeen/MiniMap.Script.txt" as MiniMap
#Include "Libs/steeffeen/Tools.Script.txt" as Tools
#Include "Libs/steeffeen/ShootMania/ObstacleScoresTable.Script.txt" as ScoresTable
#Include "Libs/steeffeen/ShootMania/ObstacleSpawnScreen.Script.txt" as ObstSpawnScreen

/*********************************************
	SETTINGS
*********************************************/

#Setting	S_TimeLimit				50.		as _("Time Limit (Minutes)")
#Setting	S_ManageAfkPlayers		True	as _("Force Afk-Players into Spec")
#Setting	S_PvPWeapons			False	as _("Enable PvP Weapons")
#Setting	S_FullAmmoSpawn			True	as _("Spawning with full Ammunition")
#Setting	S_DisablePlayerSpec		False	as _("Disable spectating of other Players during a Run")
#Setting	S_FastRespawn			True	as _("Fast respawn on the checkpoint")
#Setting	S_FastRespawnOldMap		True	as "<hidden>"	///< Enable fast respawn on old map
#Setting	S_RespawnPenalty		0		as _("Penalty for respawning")
#Setting	S_AllowJump				True	as _("Allow players to jump to another checkpoint")
#Setting	S_DisplayMedals			True	as _("Display medals earned by players at the end of a Run")

#Setting	S_NextMapVotingRatio	0.7		as "<hidden>"		// Ratio needed for the next map voting
#Setting	S_UseSameWallJump		True	as "<hidden>"		// Use old wall jump physics

/*********************************************
	CONSTANTS
*********************************************/

#Const	C_UseWeapons				True						// Players can use weapons on theirselves
#Const	C_DefaultNeutralEmblemUrl	"http://www.team-devota.com/steeffeen/images/emblem_obstacle.dds"	// Neutral emblem

#Const	T_ItemOffzone		"Obstacle\\OffzoneShield.Item.gbx"
#Const	T_ItemAmmo			"Obstacle\\Ammo.Item.gbx"

#Const	C_Module_Items				"Obstacle_ItemsModule"
#Const	C_Module_ItemsInfo			"Obstacle_ItemsInfoModule"
#Const	C_Module_RestartKey			"Obstacle_RestartKeyModule"
#Const	C_Module_CPProgress			"Obstacle_CPProgress"
#Const	C_Module_RespawnBehavior	"Obstacle_RespawnBehavior"
#Const	C_Module_NextMapVoting		"Obstacle_NextMapVoting"
#Const	C_Module_SpectateCount		"Obstacle_SpectateCount"
#Const	C_Module_Chrono				"Obstacle_Chrono"
#Const	C_Module_TimeRankInfo		"Obstacle_TimeRankInfo"
#Const	C_Module_TimeDiff			"Obstacle_TimeDiff"

#Const C_Medal_Gold		0
#Const C_Medal_Silver	5
#Const C_Medal_Bronze	15

#Const	Description		_("Finish difficult Obstacle Courses as fast as possible.\nImprove Your Movement Skills and become the Champion.")

/*********************************************
	GLOBALES
*********************************************/

declare Boolean 	G_Solo;						// Whether solo obstacle is running
declare Text		G_ModeName;					// Name of the running game mode
declare Ident		G_StartSpawnId;				// Id of the start spawn on the current map
declare Integer		G_CheckpointsTotal;			// Number of checkpoints on the current map
declare Integer		G_LastUIUpdate;				// Last UI Update
declare Text		G_DefaultMarkers;			// Set of default markers
declare Text		G_DefaultMarkerFrames;		// Set of default marker frames
declare	Ident[Text]	G_ItemIdents;				// Idents of loaded items

/*********************************************
	LABELS
*********************************************/

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Color::GetScriptName(), Color::GetScriptVersion());
MB_LogVersion(CustomUI::GetScriptName(), CustomUI::GetScriptVersion());
MB_LogVersion(Json::GetScriptName(), Json::GetScriptVersion());
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(ScoresTable::GetScriptName(), ScoresTable::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(Tabs::GetScriptName(), Tabs::GetScriptVersion());
***

***Rules***
***
SpawnScreen::ResetRulesSection();

declare OpenSpecial1Text = "$<$00f";
declare OpenSpecial2Text = "$<$88f";
declare OpenSpecial3Text = "$<$0f0";
declare OpenSpecial4Text = "$<$f80";
declare OpenBoldText = "$<$o";
declare OpenSettingText = "$<$08f";
declare CloseText = "$>";

declare ModeRules =
"""Finish the {{{OpenSpecial2Text}}}Obstacle Course{{{CloseText}}} as fast as possible.

To validate a Race you must touch the Finish after going through all the {{{OpenSpecial2Text}}}Checkpoints{{{CloseText}}}.
""";

if (!G_Solo) {
	ModeRules ^=
"""You can start over and improve your Time as often as you want during {{{OpenSettingText^S_TimeLimit^CloseText}}} Minutes.
The Player with the best Time wins the Map.
""";
}

ModeRules ^= """
Press the {{{OpenBoldText}}}Respawn{{{CloseText}}} Button (default: {{{OpenSpecial2Text}}}Backspace{{{CloseText}}}) or die to {{{OpenSpecial3Text}}}Respawn{{{CloseText}}} at the last reached Checkpoint.
Press the {{{OpenBoldText}}}Give Up{{{CloseText}}} Button (default: {{{OpenSpecial2Text}}}Delete{{{CloseText}}}) to {{{OpenSpecial3Text}}}Restart{{{CloseText}}} from the beginning. (You can also set another Restart Button at the bottom.)
""";

if (!G_Solo) {
	ModeRules ^= """
Press {{{OpenSpecial4Text}}}F3{{{CloseText}}} when you're ready for the next Map (Press F3 again to change your Decision).""";
}

ModeRules ^= """
Press {{{OpenSpecial4Text}}}F4{{{CloseText}}} to disable/enable Respawning at Checkpoints.
Press {{{OpenSpecial4Text}}}F6{{{CloseText}}} to get an Overview of the Map.""";

SpawnScreen::AddSubsection(_("Rules"), ModeRules, 5.);

SpawnScreen::CreatePrettyRules(G_ModeName);
***

***ScoresTable***
***
// Scoreboard
ScoresTable::Load(G_Solo);
ScoresTable::SetTableFormat(2, 7);
ScoresTable::SetTableWidth(220.);
ScoresTable::SetColumnsWidth(2.5, 1.5, 2.5, 18., 1.4, 1.5, 1.0, 3., 5.5, 0., 0.);
ScoresTable::SetColumnName("Custom1", "");
ScoresTable::SetColumnName("Custom2", _("|Number of respawns by a player|Respawns"));
ScoresTable::SetColumnName("Custom3", _("|Best result reached by a player|Best"));
ScoresTable::SetDefaultCustom1("");
ScoresTable::SetDefaultCustom2("-");
ScoresTable::SetDefaultCustom3("-");
ScoresTable::SetDefaultFooterScore("");
ScoresTable::SetDefaultFooterStats(TextLib::Compose("%1: %2", _("Time Limit"),
	TextLib::TimeToText(MathLib::NearestInteger(S_TimeLimit * 60. * 1000.), False)));
ScoresTable::SetTableBackgroundImage("file://Media/Manialinks/Shootmania/Common/topsBg.dds", <0., 64.>, <242., 200.>);
ScoresTable::Build();
ScoresTable::GetLayerScoresTable().Type = CUILayer::EUILayerType::Normal;

// Tabs
Tabs::Load();
declare TabsLayer <=> Tabs::CreateTabPaneLayer(["ScoresTab" => "Rankings", "CPTimes" => "Race"], 13, -3, False);
TabsLayer.Type = CUILayer::EUILayerType::AltMenu;
UIManager.UIAll.UILayers.add(TabsLayer);

// Checkpoint times
CPTimes::Load("CPTimes");
CPTimes::SetSize(<240., 100.>);
CPTimes::SetBackgroundImage("file://Media/Manialinks/Shootmania/Common/topsBg.dds", <242., 200.>, <0., 6.>);
CPTimes::Build();
***

***Ladder_OpenMatch_All***
***
Mode::Ladder_OpenMatch_All();
***

***CheckTimes***
***
// Check setting update
declare Last_TimeLimit for This = S_TimeLimit;
if (Last_TimeLimit != S_TimeLimit) {
	Last_TimeLimit = S_TimeLimit;

	// Update EndTime
	declare NewEndTime = StartTime + S_TimeLimit * 60. * 1000.;
	if (EndTime != NewEndTime) {
		if (NewEndTime < Now + 15000.) {
			NewEndTime = Now + 15000.;
		}
		EndTime = MathLib::NearestInteger(NewEndTime);
	}

	// Update rules
	---Rules---
}

// Map end conditions
if (Now >= EndTime) {
	MB_StopMap = True;
	XmlRpc.SendCallback("endMap", GetRankings());
	//continue;
}
***

***UpdateFooterStats***
***
ScoresTable::SetFooterStats(_Player, TextLib::Compose("%1: %2", _("Time Limit"),
	TextLib::TimeToText(MathLib::NearestInteger(S_TimeLimit * 60. * 1000.), False)));
***

***PlayerFinish***
***
declare netwrite Net_StartTime for _Player = 0;
declare RunLast for _Player = -1;
declare RunBest for _Player.Score = -1;
declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
declare CheckpointsTimeBest for _Player.Score = Integer[Ident];
declare RespawnCount for _Player = 0;
declare BestRespawnCount for _Player.Score = -1;
declare RunNew = 0;
declare NewBestTime = "";

RunNew = GetTime(_Player);
RunLast = RunNew;

// Find player ranking at finish
declare Rank = 1;
declare Ranking = Integer[Ident];
foreach (Score in Scores) {
	declare RunBest as OpponentRunBest for Score = -1;
	if (Score.User.Id == _Player.User.Id || OpponentRunBest <= 0) continue;
	Ranking[Score.User.Id] = OpponentRunBest;
}
Ranking[_Player.User.Id] = RunNew;
Ranking = Ranking.sort();
foreach (UserId => FinishTime in Ranking) {
	if (UserId == _Player.User.Id) break;
	Rank += 1;
}

declare SendRespawnCount = -1;
if (S_DisplayMedals) SendRespawnCount = RespawnCount;
UpdateLayerTimeDiff(_Player, RunNew, RunBest, Rank, SendRespawnCount);

// Check best time
if (RunNew < RunBest || RunBest < 0) {
	RunBest = RunNew;
	CheckpointsTimeBest = CheckpointsTimeLast;
	UpdateRanking();
	NewBestTime = _("(New Best Time!)");
}
// Check best respawns
if (RespawnCount < BestRespawnCount || BestRespawnCount < 0) {
	BestRespawnCount = RespawnCount;
}

// Submit time
declare TimeDiff = RunNew;
declare LastCheckpointId for _Player = NullId;
if (CheckpointsTimeLast.existskey(LastCheckpointId)) {
	TimeDiff -= CheckpointsTimeLast[LastCheckpointId];
}
declare Success = CPTimes::SubmitCheckpointTime(CheckpointsTimeLast.count + 1, _Player, TimeDiff);

// Check medal
declare Messages = MedalFromRunNew(_Player);
if (Messages.count >= 2) {
	UIManager.UIAll.SendNotice(Messages[1],
		CUIConfig::ENoticeLevel::Default, _Player.User, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::Silence, 0);
}

// XmlRpc callback
if (!_Player.IsFakePlayer) {
	SendXmlRpcCallback("OnFinish", _Player, RunNew, _GoalId);
	// Callback for FoxControl
	declare PlayerData = RunNew ^ "{:}" ^ _Player.User.Login;
	XmlRpc.SendCallback("playerFinish", PlayerData);
}

Net_StartTime = 0;
ClearPenalty(_Player);
UpdateCustom3(_Player);
UpdateFooterScore(_Player);
UpdateLayerInfo(_Player, RunLast, RunBest);
RestartPlayer(_Player, True, False);

declare UI <=> UIManager.GetUI(_Player);
if (UI != Null) {
	declare Time = TextLib::TimeToText(RunNew, True);
	declare Variant = 1;
	declare Color = "$f00";

	if (NewBestTime != "") {
		Variant = 0;
		Color = "$00f";
	}

	UI.SendNotice(TextLib::Compose("%1: $<%2$> %3", _("|Goal|Finish"), Color^Time, NewBestTime),
		CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::Finish, Variant);
}
***

***InitServer***
***
G_Solo = False;
G_ModeName = "Obstacle";
G_LastUIUpdate = 0;
***

***StartServer***
***
// Load items
ItemList_Begin();
G_ItemIdents[T_ItemOffzone] = ItemList_Add(T_ItemOffzone);
G_ItemIdents[T_ItemAmmo] = ItemList_Add(T_ItemAmmo);
ItemList_End();

Color::Load();
// Set mode options
UsePvPCollisions = False;
UsePvPWeapons = S_PvPWeapons;
UseClans = False;
if (MB_NeutralEmblemUrl == "") MB_NeutralEmblemUrl = C_DefaultNeutralEmblemUrl;

// UI
UIManager.UIAll.UISequence_CanSkipIntroMT = True;
SM::SetupDefaultVisibility();
SpawnScreen::SetModeName(G_ModeName);
ObstSpawnScreen::SetModeName(G_ModeName);
SpawnScreen::CreateMapInfo();
ObstSpawnScreen::CreateScores();
{---Rules---}

// Layers
declare LayerInfo <=> UIManager.UILayerCreate();
LayerInfo.ManialinkPage = CreateLayerInfo();
UIManager.UIAll.UILayers.add(LayerInfo);

declare LayerTimeDiff <=> UIManager.UILayerCreate();
LayerTimeDiff.ManialinkPage = CreateLayerTimeDiff();
UIManager.UIAll.UILayers.add(LayerTimeDiff);

declare LayerUtilities <=> UIManager.UILayerCreate();
LayerUtilities.ManialinkPage = CreateLayerUtilities();
UIManager.UIAll.UILayers.add(LayerUtilities);

declare LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
UIManager.UIAll.UILayers.add(LayerMarkers);

declare LayerItems <=> UIManager.UILayerCreate();
LayerItems.ManialinkPage = CreateLayerItems();
UIManager.UIAll.UILayers.add(LayerItems);

{---ScoresTable---}

// MiniMap
MiniMap::Load();

// Custom UI
CustomUI::Load();
CustomUI::Add(C_Module_Items, <0., -65.>, <80., 40.>, "bottom", "center");
CustomUI::Add(C_Module_ItemsInfo, <0., 40.>, <110., 10.>);
CustomUI::Add(C_Module_RestartKey, <95., -87.>, <30., 5.>);
CustomUI::Add(C_Module_CPProgress, <-47., -78.>, <40., 5.>);
CustomUI::Add(C_Module_RespawnBehavior, <-20., 88.>, <40., 4.>, "center", "right");
CustomUI::Add(C_Module_NextMapVoting, <20., 88.>, <60., 4.>, "center", "left");
CustomUI::Add(C_Module_SpectateCount, <159., -63.>, <20., 8.>, "center", "right");
CustomUI::Add(C_Module_Chrono, <50., -73.>, <40., 10.>);
CustomUI::Add(C_Module_TimeRankInfo, <159., -89.>, <40., 20.>, "bottom", "right");
CustomUI::Add(C_Module_TimeDiff, <0., 65.>, <60., 12.>);
CustomUI::Build();
***

***StartMap***
***
CPTimes::Synchro();

// UI
UIManager.UIAll.SendNotice(
	"", CUIConfig::ENoticeLevel::MatchInfo,
	Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::StartRound, 0
);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;

// Prepare new map
PrepareMap();
UIManager.UIAll.MarkersXML = CreateHud3dMarkers();
LayerMarkers.ManialinkPage = CreateLayerMarkers();
LayerMarkers.IsVisible = True;
LayerUtilities.IsVisible = True;

// Place items
foreach (AnchorLandmark in MapLandmarks_ObjectAnchor) {
	switch (AnchorLandmark.ObjectAnchor.ItemName) {
		case T_ItemOffzone: {
			declare Object = ObjectCreate(G_ItemIdents[T_ItemOffzone]);
			Object.SetAnchor(AnchorLandmark.ObjectAnchor);
			declare metadata Meta_BuffDuration for AnchorLandmark = 5.;
			declare Text ItemName for Object;
			declare Real Duration for Object;
			declare Ident AnchorLandmarkId for Object;
			ItemName = T_ItemOffzone;
			Duration = Meta_BuffDuration;
			AnchorLandmarkId = AnchorLandmark.Id;
		}
		case T_ItemAmmo: {
			declare Object = ObjectCreate(G_ItemIdents[T_ItemAmmo]);
			Object.SetAnchor(AnchorLandmark.ObjectAnchor);
			declare metadata Meta_GrantAmmoDuration for AnchorLandmark = 0.;
			declare metadata Meta_GrantAmmoAmount for AnchorLandmark = 1.;
			declare Text ItemName for Object;
			declare Real Duration for Object;
			declare Real Amount for Object;
			declare Ident AnchorLandmarkId for Object;
			ItemName = T_ItemAmmo;
			Duration = Meta_GrantAmmoDuration;
			Amount = Meta_GrantAmmoAmount;
			AnchorLandmarkId = AnchorLandmark.Id;
		}
	}
	if (Objects.count > 100) break;
}

// Init players
InitPlayer(Null, True);
InitScore(Null, True);

{---Ladder_OpenMatch_All---}
ScoresTable::StartMatch();
MiniMap::Build();

StartTime = Now + 3500;
if (!G_Solo) {
	EndTime = MathLib::NearestInteger(StartTime + S_TimeLimit * 60. * 1000.);
}

declare TargetId = NullId;
if (Players.count > 0) {
	TargetId = Players[MathLib::Rand(0, Players.count-1)].Id;
}
UpdateAutoTarget(TargetId);
***

***OnNewPlayer***
***
InitPlayer(Player, False);

declare Best = -1;
if (Player.Score != Null) {
	declare RunBest for Player.Score = -1;
	Best = RunBest;
}

declare UI <=> UIManager.GetUI(Player);
if (UI == Null) continue;

UI.ForceSpectator = False;
UI.SpectatorForcedTarget = NullId;
UI.SpectatorAutoTarget = NullId;

Tabs::UseTabs(UI, "ScoresTab");
UpdateLayerInfo(Player, 0, Best);
***

***OnNewSpectator***
***
InitPlayer(Spectator, False);

declare UI <=> UIManager.GetUI(Spectator);
if (UI == Null) continue;

UI.ForceSpectator = False;
UI.SpectatorForcedTarget = NullId;

Tabs::UseTabs(UI, "ScoresTab");
***

***Yield***
***
Tabs::XmlRpcLoop();
MiniMap::Loop();
***

***PlayLoop***
***
ManageAfkPlayers();
{---CheckTimes---}
CheckMiniMapEvents();
CheckScriptSettings();

// Manage events
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnArmorEmpty: {
			if (Event.Victim != Null) {
				if (Event.Victim.IsInOffZone) {
					// Offzone item active?
					declare netwrite ItemBuffTimes for Event.Victim = Integer[Text];
					if (ItemBuffTimes.existskey(T_ItemOffzone) && ItemBuffTimes[T_ItemOffzone] >= Now) {
						// Item effect lets player walk through offzone
						Discard(Event);
						continue;
					}
				}
				RestartPlayer(Event.Victim, False, False);
				if (!Event.Victim.IsFakePlayer) {
					XmlRpc::OnArmorEmpty(Event);
				}
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			if (Event.Player != Null) {
				RestartPlayer(Event.Player, False, False);
				if (!Event.Player.IsFakePlayer) {
					XmlRpc::OnPlayerRequestRespawn(Event);
				}
			}
			Discard(Event);
		}
		case CSmModeEvent::EType::OnHit: {
			Discard(Event);
		}
		case CSmModeEvent::EType::OnPlayerTouchesObject: {
			if (Event.Object == Null || Event.Player == Null) {
				Discard(Event);
				continue;
			}
			declare PickedUp = False;
			declare ItemName for Event.Object = "";
			switch (ItemName) {
				case T_ItemOffzone: {
					// Offzone pickup
					declare netwrite ItemBuffTimes for Event.Player = Integer[Text];
					declare Duration for Event.Object = 5.;
					if (!ItemBuffTimes.existskey(T_ItemOffzone) || ItemBuffTimes[T_ItemOffzone] < Now) {
						ItemBuffTimes[T_ItemOffzone] = Now + MathLib::NearestInteger(Duration * 1000.);
						PickedUp = True;
					}
				}
				case T_ItemAmmo: {
					// Ammo item
					declare netwrite ItemBuffTimes for Event.Player = Integer[Text];
					if (!ItemBuffTimes.existskey(T_ItemAmmo)) {
						declare Duration for Event.Object = 0.;
						declare Amount for Event.Object = 1.;
						ItemBuffTimes[T_ItemAmmo] = Now + MathLib::NearestInteger(Duration * 1000.);
						declare Real AmmoItemBuffDuration for Event.Player;
						declare Real AmmoItemBuffAmount for Event.Player;
						AmmoItemBuffDuration = Duration;
						AmmoItemBuffAmount = Amount;
						if (Duration <= 0.) {
							// Instant grant
							AddPlayerAmmo(Event.Player, Tools::GetCurrentWeapon(Event.Player), Amount);
						}
						PickedUp = True;
					}
				}
			}
			if (PickedUp) {
				PassOn(Event);
			} else {
				Discard(Event);
			}
		}
		default: {
			PassOn(Event);
		}
	}
}

// Manage players
foreach (Player in Players) {
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			RestartPlayer(Player, False, False);
		}
		case CSmPlayer::ESpawnStatus::Spawned: {
			if (Player.User.RequestsSpectate) {
				UnspawnPlayer(Player);
				continue;
			}

			// Manage item effects
			declare netwrite ItemBuffTimes for Player = Integer[Text];
			foreach (ItemName => BuffTime in ItemBuffTimes) {
				if (BuffTime < Now) continue;
				switch (ItemName) {
					case T_ItemAmmo: {
						declare AmmoItemBuffDuration for Player = 0.;
						if (AmmoItemBuffDuration <= 0.) continue;
						declare AmmoItemBuffAmount for Player = 1.;
						declare TickAmount = AmmoItemBuffAmount / (AmmoItemBuffDuration * 1000. / Period);
						AddPlayerAmmo(Player, Tools::GetCurrentWeapon(Player), TickAmount);
					}
				}
			}

			// Manage checkpoints + goals
			if (Player.CapturedLandmark == Null || Player.Score == Null) continue;
			declare CheckpointsTimeLast for Player.Score = Integer[Ident];
			switch (Player.CapturedLandmark.Tag) {
				case "Goal": {
					if (CheckpointsTimeLast.count >= G_CheckpointsTotal) {
						// Run finish
						ActivateFinish(Player, Player.CapturedLandmark.Id);
						continue;
					}
					// Checkpoint missed
					declare LastStatusMessage for Player = 0;
					if (LastStatusMessage + 2500 >= Now) continue;
					LastStatusMessage = Now;
					declare CheckpointsDiff = G_CheckpointsTotal - CheckpointsTimeLast.count;
					declare Message = "";
					if (CheckpointsDiff > 1) {
						Message = TextLib::Compose(_("%1You missed %2 Checkpoints!"), "$f00", TextLib::ToText(CheckpointsDiff));
					} else {
						Message = TextLib::Compose("$f00%1", _("You missed a Checkpoint!"));
					}
					Message::SendBigMessage(Player, Message, 2000, 2, CUIConfig::EUISound::Warning, 1);

					// Mark missing checkpoints
					UpdatePoleIds(Player);
				}
				case "No-Function": {
					// Inactive pole
					declare LastStatusMessage for Player = 0;
					if (LastStatusMessage + 2500 >= Now) continue;
					LastStatusMessage = Now;
					Message::SendStatusMessage(Player, _("Inactive Pole!"), 2000, 0);
				}
				case "Portal": {
					// Portal
					UsePortal(Player, Player.CapturedLandmark.Id);
				}
				default: {
					// Checkpoint?
					if (!IsCheckpoint(Player.CapturedLandmark) || CheckpointsTimeLast.existskey(Player.CapturedLandmark.Id)) continue;
					// New Checkpoint!
					ActivateCheckpoint(Player, Player.CapturedLandmark.Id);
				}
			}
		}
	}
}

// Manage objects
foreach (Object in Objects) {
	if (Object.Status != CSmObject::EStatus::OnAnchor) {
		declare AnchorLandmarkId for Object = NullId;
		if (MapLandmarks_ObjectAnchor.existskey(AnchorLandmarkId)) {
			declare AnchorLandmark <=> MapLandmarks_ObjectAnchor[AnchorLandmarkId];
			Object.SetAnchor(AnchorLandmark.ObjectAnchor);
		}
	}
}

// Handle xmlrpc callbacks
foreach (Event in XmlRpc.PendingEvents) {
	switch (Event.Param1) {
		case "Obstacle.JumpTo": {
			// Get player that wants to jump
			declare Params = TextLib::Split(";", Event.Param2);
			if (Params.count < 2) continue;
			declare Login = Params[0];
			declare Player <=> Tools::GetPlayer(Login);
			if (Player == Null || Player.Score == Null) continue;
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;
			declare Ident LastCheckpointId as PlayerCPId for Player;

			// Perform jump
			declare Index = TextLib::ToInteger(Params[1]);
			if (Index >= 0) {
				// Jump to checkpoint
				declare CSmMapLandmark Target <=> Null;
				foreach (GaugeLandmark in MapLandmarks_Gauge) {
					if (!IsCheckpoint(GaugeLandmark)) continue;
					if (GaugeLandmark.Order != Index) continue;
					Target <=> GaugeLandmark;
					break;
				}
				if (Target == Null) {
					declare PoleIndex = 0;
					foreach (GaugeLandmark in MapLandmarks_Gauge) {
						if (!IsCheckpoint(GaugeLandmark)) continue;
						if (PoleIndex == Index) {
							Target <=> GaugeLandmark;
							break;
						}
						PoleIndex += 1;
					}
				}
				if (Target == Null) {
					// Invalid pole
					UI.SendChat("$f00Invalid Checkpoint Index '"^Index^"'!");
					continue;
				}
				// Jump
				UI.SendChat("$0f0Jumping to Checkpoint '"^Index^"'!");
				PlayerCPId = Target.Id;
				RestartPlayer(Player, False, True);
			} else {
				// Jump to player
				declare Target = Tools::GetPlayer(Params[1]);
				if (Target == Null) {
					// Invalid target
					UI.SendChat("$f00Invalid Jump Target '"^Params[1]^"'!");
					continue;
				}
				// Jump
				UI.SendChat("$0f0Jumping to '"^Target.User.Login^"'!");
				declare LastCheckpointId as TargetCPId for Target = NullId;
				PlayerCPId = TargetCPId;
				RestartPlayer(Player, False, True);
			}

			// Invalidate time
			declare netwrite Boolean Net_UsedJump for Player;
			Net_UsedJump = True;
		}
	}
}

// Jumps
declare JumpRequests = CPTimes::PendingJumps();
foreach (Player => CPId in JumpRequests) {
	JumpToCheckpoint(Player, CPId);
}

// UI
Message::Loop();
if (G_LastUIUpdate + 250 < Now) {
	G_LastUIUpdate = Now;

	UpdateLayerUtilities();

	// Update net checkpoint counts
	foreach (Player in Players) {
		if (Player.Score == Null) continue;
		declare CheckpointsTimeLast for Player.Score = Integer[Ident];
		declare netwrite Integer Net_CheckpointCount for Player;
		Net_CheckpointCount = CheckpointsTimeLast.count;
	}
}
***

***ObstacleEndMap***
***
ScoresTable::EndMatch();
foreach (Player in AllPlayers) {
	declare netwrite Integer Net_StartTime for Player;
	Net_StartTime = 0;
	ClearPenalty(Player);
}
StartTime = -1;
EndTime = -1;

// Clean players messages
Message::CleanBigMessages();
Message::CleanStatusMessages();
MB_Yield();

// Search the user id of the winner
declare ScoreTimes = Integer[Ident];
declare CSmScore WinnerScore <=> Null;
declare Best = -1;
declare Worst = -1;
foreach (Score in Scores) {
	Score.Points = 0;
	Score.RoundPoints = 0;
	declare RunBest for Score = -1;
	if (RunBest > 0) {
		ScoreTimes[Score.Id] = RunBest;
		if (RunBest < Best || Best < 0) {
			// Better time
			Best = RunBest;
			WinnerScore <=> Score;
		} else {
			if (RunBest == Best) {
				// Same time - Check respawn counts
				declare BestRespawnCount as BestRS for WinnerScore = -1;
				declare BestRespawnCount as RSCount for Score = -1;
				if (RSCount >= 0 && (BestRS < 0 || RSCount < BestRS)) {
					Best = RunBest;
					WinnerScore <=> Score;
				}
			}
		}
		if (RunBest > Worst) {
			Worst = RunBest;
		}
	}
}
// Sort scores for the ladder
foreach (Score in Scores) {
	declare RunBest for Score = -1;
	if (RunBest > 0) {
		Score.LadderRankSortValue = RunBest;
	} else {
		declare CheckpointsTimeLast for Score = Integer[Ident];
		declare SortValue = MathLib::ToReal(Worst);
		if (G_CheckpointsTotal > 0) {
			SortValue *= 2. - (1. * CheckpointsTimeLast.count / (1. * G_CheckpointsTotal));
		}
		Score.LadderRankSortValue = MathLib::NearestInteger(SortValue);
	}
}
ScoreTimes = ScoreTimes.sort();
declare Index = 0;
foreach (Id => Time in ScoreTimes) {
	if (!Scores.existskey(Id)) continue;
	declare Score <=> Scores[Id];
	Score.Points = 1000 - Index * 35;
	Index += 1;
}

Mode::Ladder_CloseMatch();

// Hide ui stuff
LayerMarkers.IsVisible = False;
LayerUtilities.IsVisible = False;

// Announce winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
declare Message = _("|Match|Draw");
if (WinnerScore != Null && WinnerScore.User != Null) {
	Message = TextLib::Compose(_("%1 wins the Map!"), "$<"^WinnerScore.User.Name^"$>");
}
Message::SendBigMessage(Message, 4000, 3, CUIConfig::EUISound::EndRound, 2);
MB_Sleep(2500);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
MB_Sleep(4500);
wait(UIManager.UIAll.UISequenceIsCompleted);
Message::CleanBigMessages();
***

***EndMap***
***
---ObstacleEndMap---
ObjectDestroyAll();
***

***EndServer***
***
ScoresTable::Unload();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyMapInfo();
ObstSpawnScreen::DestroyScores();
MiniMap::Unload();
CustomUI::Unload();
UIManager.UILayerDestroyAll();
***

/*********************************************
	FUNCTIONS
*********************************************/

// Dummy method for empty labels
Void DoNothing() {}

// Check if the given player is free to spec anyone
Boolean CanFreeSpec(CSmPlayer _Player) {
	if (_Player == Null) return False;
	if (Spectators.existskey(_Player.Id)) {
		return True;
	}
	if (S_DisablePlayerSpec && Players.existskey(_Player.Id)) {
		return False;
	}
	return True;
}

// Check script settings
Void CheckScriptSettings() {
	// PvP weapons
	UsePvPWeapons = S_PvPWeapons;
	declare OldUsePvPWeapons for This = UsePvPWeapons;
	if (OldUsePvPWeapons != UsePvPWeapons) {
		OldUsePvPWeapons = UsePvPWeapons;
		if (UsePvPWeapons) {
			UIManager.UIAll.SendChat("$<$f80PvP Weapons$> are now $<$0f0enabled$>!");
		} else {
			UIManager.UIAll.SendChat("$<$f80PvP Weapons$> are now $<$f00disabled$>!");
		}
	}

	// Wall jumps
	UseSameWallJump = S_UseSameWallJump;
}

// Check if the given pole is a valid checkpoint
Boolean IsCheckpoint(CSmMapLandmark _GaugeLandmark) {
	if (_GaugeLandmark == Null || _GaugeLandmark.Gauge == Null) return False;
	return ("Checkpoint" == TextLib::SubText(_GaugeLandmark.Tag, 0, 10));
}

// Send xmlrpc callback
Void SendXmlRpcCallback(Text _CallbackName, CSmPlayer _Player, Integer _RunTime, Ident _CheckpointId) {
	if (_Player == Null || _Player.IsFakePlayer || _Player.Score == Null || _CallbackName == "" || _RunTime <= 0) return;
	declare RespawnCount for _Player = 0;
	declare JSON = "";

	// Player information
	JSON ^= Json::StringifyMinimal("Player", _Player, "")^",";

	// Run information
	JSON ^= """ "Run":{""";
	JSON ^= Json::Stringify("Time", _RunTime)^",";
	JSON ^= Json::Stringify("RespawnCount", RespawnCount)^",";

	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	JSON ^= Json::Stringify("CheckpointIndex", CheckpointsTimeLast.count-1)^",";
	JSON ^= """ "CheckpointId":"{{{_CheckpointId}}}"}""";

	XmlRpc.SendCallback(_CallbackName, Json::Enfold(JSON));
}

// Determine closest CPSpawn
Ident GetClosestSpawn(Ident _CheckPointId, Ident[] _SpawnIds) {
	if (!MapLandmarks_Gauge.existskey(_CheckPointId)) return NullId;
	declare GaugeLandmark <=> MapLandmarks_Gauge[_CheckPointId];
	declare ClosestSpawn = NullId;
	declare ClosestDistance = -1.0;
	foreach (Id in _SpawnIds) {
		if (!MapLandmarks_PlayerSpawn.existskey(Id)) continue;
		declare SpawnLandmark <=> MapLandmarks_PlayerSpawn[Id];
		declare Distance = MathLib::Distance(GaugeLandmark.Position, SpawnLandmark.Position);
		if (Distance >= ClosestDistance && ClosestDistance >= 0) continue;
		ClosestDistance = Distance;
		ClosestSpawn = SpawnLandmark.Id;
	}
	return ClosestSpawn;
}
Ident GetClosestSpawn(Ident _CheckPointId) {
	if (!MapLandmarks_Gauge.existskey(_CheckPointId)) return NullId;
	declare GaugeLandmark <=> MapLandmarks_Gauge[_CheckPointId];
	declare SpawnIds = Ident[];

	foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
		if (SpawnLandmark.Tag == "No-Function") continue;
		if (SpawnLandmark.Tag != "CPSpawn") continue;
		if (GaugeLandmark.Order != 0 && GaugeLandmark.Order != SpawnLandmark.Order) continue;
		SpawnIds.add(SpawnLandmark.Id);
	}
	if (SpawnIds.count > 0) return GetClosestSpawn(_CheckPointId, SpawnIds);

	foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
		if (SpawnLandmark.Tag != "CPSpawn") continue;
		if (GaugeLandmark.Order <= SpawnLandmark.Order) continue;
		SpawnIds.add(SpawnLandmark.Id);
	}
	return GetClosestSpawn(_CheckPointId, SpawnIds);
}

// Update pole ids net variable for markers for the given player
Void UpdatePoleIds(CSmPlayer _Player) {
	if (_Player == Null || _Player.Score == Null) return;

	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	declare netwrite Text Net_PoleIds for _Player;

	declare PoleIds = Ident[];
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		if (GaugeLandmark.Tag == "No-Function") continue;
		if (CheckpointsTimeLast.existskey(GaugeLandmark.Id)) continue;
		if (GaugeLandmark.Tag == "Goal" && CheckpointsTimeLast.count < G_CheckpointsTotal) continue;
		if (GaugeLandmark.Tag == "Portal") {
			declare SpawnId = GetClosestSpawn(GaugeLandmark.Id);
			if (MapLandmarks_PlayerSpawn.existskey(SpawnId)) PoleIds.add(SpawnId);
		}
		if (GaugeLandmark.Order > 0 && GaugeLandmark.Order != CheckpointsTimeLast.count + 1) continue;
		PoleIds.add(GaugeLandmark.Id);
	}

	declare String = "";
	foreach (Index => PoleId in PoleIds) {
		String ^= PoleId;
		if (Index < PoleIds.count) String ^= ",";
	}

	Net_PoleIds = String;
}

// Parse 3char hex color to 6char hex color
Text GetColorizeColor(Vec3 _Color) {
	declare ColorText = Color::RgbToHex(_Color);
	declare Colorize = "";
	for (Index, 0, TextLib::Length(ColorText)) {
		declare Char = TextLib::SubString(ColorText, Index, 1);
		Colorize ^= Char^Char;
	}
	return Colorize;
}

// Darken a given color by a given factor
Vec3 DarkenColor(Vec3 _Color, Real _Factor) {
	declare Color = _Color;
	for (Index, 0, 2) {
		Color[Index] *= _Factor;
	}
	return Color;
}

// Upscale a given color
Vec3 UpscaleColor(Vec3 _Color) {
	declare Factor = -1.0;
	for (Index, 0, 2) {
		if (_Color[Index] > 0.0) {
			declare ChannelFactor = 1.0 / _Color[Index];
			if (ChannelFactor < Factor || Factor < 0) {
				Factor = ChannelFactor;
			}
		}
	}
	declare Color = _Color;
	for (Index, 0, 2) {
		Color[Index] *= Factor;
	}
	return Color;
}

// Create markers layer manialink
Text CreateLayerMarkers() {
	declare Manialink = """
<manialink version="1" name="Obstacle_LayerMarkers">
	<now value="{{{Now}}}"/>
	<script><!--
		#Include "TextLib" as TextLib

		#Const	C_CheckpointsTotal	{{{G_CheckpointsTotal}}}

		CSmScriptBlockPole GetPole(Text _Id) {
			foreach (Pole in BlockPoles) {
				if (_Id != ""^Pole.Id) continue;
				return Pole;
			}
			return Null;
		}

		main() {
			wait(InputPlayer != Null);

			declare LastUIUpdate = 0;
			declare LastPoleIds = "-";
			declare LastCheckpointCount = -1;

			declare MainFrame = Page.MainFrame;
			if (MainFrame.Controls.count == 1 && MainFrame.Controls.existskey(0)) MainFrame = (MainFrame.Controls[0] as CMlFrame);

			while (True) {
				yield;

				if (LastUIUpdate + 200 > Now || !PageIsVisible) continue;
				LastUIUpdate = Now;

				declare LocalPlayer <=> InputPlayer;
				if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;

				declare netread Net_CheckpointCount for LocalPlayer = -1;
				declare netread Net_PoleIds for LocalPlayer = "";
				if (LastCheckpointCount == Net_CheckpointCount && LastPoleIds == Net_PoleIds) continue;
				LastCheckpointCount = Net_CheckpointCount;
				LastPoleIds = Net_PoleIds;

				declare PoleIds = TextLib::Split(",", Net_PoleIds);

				foreach (Control in MainFrame.Controls) {
					declare Frame <=> (Control as CMlFrame);
					declare Frame_Content <=> (Frame.GetFirstChild("Content") as CMlFrame);
					if (Frame_Content == Null) continue;
					Frame_Content.Visible = False;
				}

				foreach (PoleId in PoleIds) {
					declare Frame_Portal <=> (MainFrame.GetFirstChild("Frame_Portal_"^PoleId) as CMlFrame);
					if (Frame_Portal != Null) {
						Frame_Portal <=> (Frame_Portal.GetFirstChild("Content") as CMlFrame);
						declare Frame_Portal2 <=> (MainFrame.GetFirstChild("Frame_Portal__"^PoleId) as CMlFrame);
						Frame_Portal2 <=> (Frame_Portal2.GetFirstChild("Content") as CMlFrame);
						if (Frame_Portal != Null && Frame_Portal2 != Null) {
							Frame_Portal.Visible = True;
							Frame_Portal2.Visible = True;
						}
						continue;
					}

					declare Frame <=> (MainFrame.GetFirstChild("Frame_Marker"^PoleId) as CMlFrame);
					if (Frame == Null) continue;
					declare Frame_Content <=> (Frame.GetFirstChild("Content") as CMlFrame);
					if (Frame_Content == Null) continue;

					declare Pole <=> GetPole(PoleId);
					if (Pole == Null) {
						// Not a valid marker
						Frame_Content.Visible = False;
					} else {
						// Pole marker
						Frame_Content.Visible = True;
						declare Label_Text <=> (Frame_Content.GetFirstChild("Label_Text") as CMlLabel);
						if (Label_Text == Null) continue;
						if (Pole.Tag == "Goal") {
							// Goal
							Label_Text.Value = _("|Finish|Goal");
						} else {
							// Checkpoint
							declare Text Message;
							if (Net_CheckpointCount < 0) {
								Message = _("|Checkpoint|CP");
							} else {
								Message = TextLib::Compose("%1 %2", _("|Checkpoint|CP"), TextLib::ToText(Net_CheckpointCount+1));
							}
							Label_Text.Value = Message;
						}
					}
				}
			}
		}
	--></script>
	<framemodel id="FrameModel_Marker">
		<frame id="Content" hidden="1">
			<label id="Label_Text" posn="0 2 1" textsize="1" halign="center" valign="center2"/>
			<quad id="Quad_Background" posn="0 2 0" sizen="11 4" halign="center" valign="center2" style="BgsPlayerCard" substyle="BgMediaTracker"/>
			<quad id="Quad_Arrow" posn="0 0 1" sizen="4 8.5" opacity="0.35" halign="center" valign="center2" colorize="1 1 1"
				image="file://Media/Manialinks/ShootMania/Common/target.dds"/>
		</frame>
	</framemodel>
	<framemodel id="FrameModel_CP">
		<frame id="Content" hidden="1">
			<quad posn="0 0 1" sizen="4 8.5" opacity="0.5" halign="center" valign="center2" colorize="1 1 1"
				image="file://Media/Manialinks/ShootMania/Common/target.dds"/>
		</frame>
	</framemodel>""";
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		if (GaugeLandmark.Tag == "No-Function" || GaugeLandmark.Tag == "Gate") continue;
		if (GaugeLandmark.Tag != "Goal" && GaugeLandmark.Order == 0) {
			Manialink ^= """<frameinstance id="Frame_Marker{{{GaugeLandmark.Id}}}" modelid="FrameModel_CP" hidden="1"/>""";
		} else {
			Manialink ^= """<frameinstance id="Frame_Marker{{{GaugeLandmark.Id}}}" modelid="FrameModel_Marker" hidden="1"/>""";
		}
	}
	Manialink ^= G_DefaultMarkerFrames;
	Manialink ^= """
</manialink>""";
	return Manialink;
}

// Create hud3dmarkers
Text CreateHud3dMarkers() {
	declare Markers = """<now value="{{{Now}}}"/>""";
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		if (GaugeLandmark.Tag == "No-Function" || GaugeLandmark.Tag == "Gate") continue;
		Markers ^= """<marker pos="{{{Tools::GetPosn(GaugeLandmark.Position)}}}" box="0 6 0" visibility="WhenInFrustum"
			manialinkframeid="Frame_Marker{{{GaugeLandmark.Id}}}"/>""";
	}
	return Markers^G_DefaultMarkers;
}

// Prepare new map
Void PrepareMap() {
	declare PortalImageUrl = "file://Media/Images/Obstacle/Script/PortalGreen.png";

	G_StartSpawnId = NullId;
	G_CheckpointsTotal = 0;
	declare CheckpointOrders = Integer[];

	G_DefaultMarkers = "";
	G_DefaultMarkerFrames = "";

	foreach (Base in MapBases) {
		Base.IsActive = True;
	}
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		GaugeLandmark.Gauge.ValueReal = 1.0;
		if (IsCheckpoint(GaugeLandmark)) {
			if (GaugeLandmark.Order == 0 || !CheckpointOrders.exists(GaugeLandmark.Order)) {
				G_CheckpointsTotal += 1;
				CheckpointOrders.add(GaugeLandmark.Order);
			}
		} else if (GaugeLandmark.Tag == "Portal" || GaugeLandmark.Tag == "CheckpointType3") {
			declare SpawnId = GetClosestSpawn(GaugeLandmark.Id);
			if (!MapLandmarks_PlayerSpawn.existskey(SpawnId)) continue;
			declare SpawnLandmark <=> MapLandmarks_PlayerSpawn[SpawnId];
			declare Color	= UpscaleColor(Color::GetNewColor());
			declare Color1	= GetColorizeColor(Color);
			declare Color2	= GetColorizeColor(DarkenColor(Color, 0.7));

			G_DefaultMarkers ^= """
<marker box="0 1 0" visibility="WhenVisible" manialinkframeid="Frame_Portal_{{{GaugeLandmark.Id}}}"
	pos="{{{Tools::GetPosn(GaugeLandmark.Position + <0., 1., 0.>)}}}"/>
<marker box="0 0.5 0" visibility="WhenVisible" manialinkframeid="Frame_Portal__{{{GaugeLandmark.Id}}}"
	pos="{{{Tools::GetPosn(SpawnLandmark.Position + <2. /*+ SpawnLandmark.DirFront.X*/, /*2. * SpawnLandmark.DirFront.Y +*/ 3., 0./*2. * SpawnLandmark.DirFront.Z*/>)}}}"/>""";

			G_DefaultMarkerFrames ^= """
<frame id="Frame_Portal_{{{GaugeLandmark.Id}}}" hidden="1">
	<frame id="Content" hidden="1">
		<quad sizen="5.5 9" colorize="{{{Color1}}}" halign="center" valign="center2" image="{{{PortalImageUrl}}}"/>
	</frame>
</frame>
<frame id="Frame_Portal__{{{GaugeLandmark.Id}}}" hidden="1">
	<frame id="Content" hidden="1">
		<quad sizen="5.5 9" colorize="{{{Color2}}}" halign="center" valign="center2" image="{{{PortalImageUrl}}}"/>
	</frame>
</frame>""";
		}
	}
	foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
		if (TextLib::SubString(SpawnLandmark.Tag, 0, 5) != "Spawn") continue;
		G_StartSpawnId = SpawnLandmark.Id;
		break;
	}

	declare netwrite Integer Net_CheckpointsTotal for Teams[0];
	Net_CheckpointsTotal = G_CheckpointsTotal;
	CPTimes::SetNbCheckpoints(G_CheckpointsTotal + 1);
	CPTimes::ResetTimes();

	if (!MapLandmarks_PlayerSpawn.existskey(G_StartSpawnId)) {
		// Error in map
		log("ERROR: No Start Spawn on this Map!");
		UIManager.UIAll.SendChat("$f00ERROR: No Start Spawn on this Map!");
		MB_StopMap = True;
	}
}

// Update the ranking of the players
Void UpdateRanking() {
	// Split finished and unfinished players
	declare Finished = CSmScore[];
	declare Unfinished = CSmScore[];

	foreach (Score in Scores) {
		declare RunBest for Score = -1;
		if (RunBest > 0) {
			Finished.add(Score);
		} else {
			Unfinished.add(Score);
		}
	}

	// Unfinished players based on checkpoints reached
	foreach (Score in Unfinished) {
		declare CheckpointsTimeLast for Score = Integer[Ident];
		declare Points = CheckpointsTimeLast.count;

		// Penalty for offline players
		declare Player = Tools::GetPlayer(Score.User.Login);
		if (Player == Null) {
			Points -= G_CheckpointsTotal;
		}

		Score.Points = 3 * Points;
	}

	// Finished players based on their times
	declare FinishTimes = Integer[Ident];
	declare Worst = -1;
	foreach (Score in Finished) {
		declare RunBest for Score = -1;
		declare Time = RunBest / 1000;
		FinishTimes[Score.Id] = Time;
		if (RunBest > Worst) {
			Worst = Time;
		}
	}
	foreach (ScoreId => Time in FinishTimes) {
		Scores[ScoreId].Points = Worst - Time + 4 * G_CheckpointsTotal;
	}
}

// Create the info layer manialink
Text CreateLayerInfo() {
	return """
<manialink version="1" name="Obstacle_LayerInfo">
	<script><!--
		#Include "TextLib" as TextLib

		// Get the current time of a player
		Integer GetTime(CPlayer _Player) {
			if (_Player == Null) return 0;

			declare netread Net_Obstacle_Penalty for _Player = 0;
			declare netread Net_StartTime for _Player = 0;
			return (GameTime - Net_StartTime) + Net_Obstacle_Penalty;
		}

		main() {
			wait(InputPlayer != Null && Page != Null);

			declare Frame_TimeRankInfo	<=> (Page.GetFirstChild("Frame_TimeRankInfo") as CMlFrame);
			declare Label_PosTotal		<=> (Frame_TimeRankInfo.GetFirstChild("Label_PosTotal") as CMlLabel);
			declare Label_PosCurrent	<=> (Frame_TimeRankInfo.GetFirstChild("Label_PosCurrent") as CMlLabel);
			declare Label_BestTime		<=> (Frame_TimeRankInfo.GetFirstChild("Label_BestTime") as CMlLabel);
			declare Label_PrevTime		<=> (Frame_TimeRankInfo.GetFirstChild("Label_PrevTime") as CMlLabel);

			declare Frame_Chrono		<=> (Page.GetFirstChild("Frame_Chrono") as CMlFrame);
			declare Label_Chrono		<=> (Frame_Chrono.GetFirstChild("Label_Chrono") as CMlLabel);
			Frame_Chrono.Visible = True;

			declare netread Integer Net_BestTime for UI;
			declare netread Integer Net_PrevTime for UI;
			declare PosTotal = -2;
			declare PosCurrent = -2;
			declare BestTime = -2;
			declare PrevTime = -2;
			declare LastUpdate = 0;
			declare PrevUsedJump = False;

			{{{CustomUI::InjectMLInit()}}}

			while (True) {
				yield;

				if (!PageIsVisible) continue;

				declare LocalPlayer <=> InputPlayer;
				if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;

				declare netread Net_UsedJump for LocalPlayer = False;
				if (PrevUsedJump != Net_UsedJump) {
					PrevUsedJump = Net_UsedJump;

					if (Net_UsedJump) Label_Chrono.TextColor = <0.7, 0., 0.>;
					else Label_Chrono.TextColor = <1., 1., 1.>;
				}

				// Chrono
				declare netread Net_StartTime for LocalPlayer = -1;
				declare LastStartTime for LocalPlayer = -1;
				if (Net_StartTime > 0) {
					Frame_Chrono.Visible = True;
					declare netread Net_CurrentTime for LocalPlayer = -1;
					if (Net_CurrentTime > 0 && LastStartTime == Net_StartTime) {
						Label_Chrono.Value = TextLib::TimeToText(Net_CurrentTime, True);
					} else {
						Label_Chrono.Value = TextLib::TimeToText(GetTime(LocalPlayer), True);
						if (Net_CurrentTime < 0) {
							LastStartTime = Net_StartTime;
						}
					}
				} else {
					Frame_Chrono.Visible = False;
				}

				if (LastUpdate + 250 > Now) continue;
				LastUpdate = Now;

				// Info at bottom right
				Frame_TimeRankInfo.Visible = !IsSpectatorMode;
				if (PosTotal != Scores.count) {
					PosTotal = Scores.count;
					Label_PosTotal.Value = "/"^PosTotal;
				}
				if (Scores.exists(InputPlayer.Score) && PosCurrent != Scores.keyof(InputPlayer.Score)) {
					PosCurrent = Scores.keyof(InputPlayer.Score);
					Label_PosCurrent.Value = TextLib::ToText(PosCurrent + 1);
				}

				if (BestTime != Net_BestTime) {
					BestTime = Net_BestTime;
					declare BestTimeString = "";
					if (BestTime <= 0) {
						BestTimeString = TextLib::Compose(_("|Best result|Best: %1"), "--:--.--");
					} else {
						BestTimeString = TextLib::Compose(_("|Best result|Best: %1"), TextLib::TimeToText(BestTime, True));
					}
					Label_BestTime.Value = BestTimeString;
				}

				if (PrevTime != Net_PrevTime) {
					PrevTime = Net_PrevTime;
					declare PrevTimeString = "";
					if (PrevTime <= 0) {
						PrevTimeString = TextLib::Compose(_("|Previous result|Previous: %1"), "--:--.--");
					} else {
						PrevTimeString = TextLib::Compose(_("|Previous result|Previous: %1"), TextLib::TimeToText(PrevTime, True));
					}
					Label_PrevTime.Value = PrevTimeString;
				}

				{{{CustomUI::InjectMLLoop()}}}
			}
		}
	--></script>
	<frame id="{{{C_Module_TimeRankInfo}}}" class="LibCustomUI_Module">
		<frame id="Frame_TimeRankInfo" posn="159 -89">
			<label id="Label_PosTotal" posn="-7 11" halign="left" valign="bottom" textemboss="1"/>
			<label id="Label_PosCurrent" posn="-7 10" halign="right" valign="bottom" style="TextRaceChrono"/>
			<label id="Label_BestTime" posn="-2 6" sizen="40 6" halign="right" valign="bottom" textemboss="1"/>
			<label id="Label_PrevTime" posn="-2 0" sizen="40 6" halign="right" valign="bottom" textemboss="1"/>
		</frame>
	</frame>
	<frame id="{{{C_Module_Chrono}}}" class="LibCustomUI_Module">
		<frame id="Frame_Chrono" posn="50 -73" hidden="1">
			<label id="Label_Chrono" posn="0 -0.9 1" sizen="40 10" style="TextRaceChrono" halign="center" valign="center2"/>
			<quad posn="0 0" sizen="40 10" style="BgsPlayerCard" substyle="BgPlayerCard" halign="center" valign="center2"/>
		</frame>
	</frame>
</manialink>""";
}

// Update the info layer
Void UpdateLayerInfo(CSmPlayer _Player, Integer _RunLast, Integer _RunBest) {
	if (_Player == Null) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;
	declare netwrite Net_PrevTime for UI = -1;
	declare netwrite Net_BestTime for UI = -1;
	Net_PrevTime = _RunLast;
	Net_BestTime = _RunBest;
}

// Create the timediff layer manialink
Text CreateLayerTimeDiff() {
	return """
<manialink version="1" name="Obstacle_LayerTimeDiff">
	<script><!--
		#Include "TextLib" as TextLib

		main() {
			wait(InputPlayer != Null);

			declare Frame_TimeDiff <=> (Page.GetFirstChild("Frame_TimeDiff") as CMlFrame);
			declare Label_Time <=> (Frame_TimeDiff.GetFirstChild("Label_Time") as CMlLabel);
			declare Label_Diff <=> (Frame_TimeDiff.GetFirstChild("Label_Diff") as CMlLabel);
			declare Label_Rank <=> (Frame_TimeDiff.GetFirstChild("Label_Rank") as CMlLabel);

			declare Frame_Medal <=> (Page.GetFirstChild("Frame_Medal") as CMlFrame);
			declare Quad_Medal <=> (Frame_Medal.GetFirstChild("Quad_Medal") as CMlQuad);
			declare Label_Medal <=> (Frame_Medal.GetFirstChild("Label_Medal") as CMlLabel);

			declare netread Net_LayerTimeDiffUpdated for UI = 0;
			declare netread Net_Time1 for UI = 0;
			declare netread Net_Time2 for UI = 0;
			declare netread Net_CheckpointRank for UI = 0;
			declare netread Net_RespawnCount for UI = -1;
			declare LayerTimeDiffUpdated = 0;
			declare ShowTimeDiff = False;

			while (True) {
				yield;

				if (!PageIsVisible) continue;

				if (ShowTimeDiff && LayerTimeDiffUpdated + 3000 < ArenaNow) {
					ShowTimeDiff = False;
					Frame_TimeDiff.Hide();
				}

				if (Net_LayerTimeDiffUpdated != LayerTimeDiffUpdated) {
					LayerTimeDiffUpdated = Net_LayerTimeDiffUpdated;

					declare DiffString = "";
					declare Diff = 0;
					declare TimeString = TextLib::TimeToText(Net_Time1, True);

					if (Net_Time1 < 0 || Net_Time2 < 0) {
						Diff = 0;
					} else {
						Diff = Net_Time1 - Net_Time2;
					}

					if (Diff < 0) {
						DiffString = "$s$00f" ^ TextLib::TimeToText(Diff, True);
					} else {
						if (Diff == 0) {
							DiffString = "$s$0f0 (00:00.00)";
						} else {
							if (Diff > 0) {
								DiffString = "$s$f00+" ^ TextLib::TimeToText(Diff, True);
							}
						}
					}

					Label_Diff.SetText(DiffString);
					Label_Time.SetText("$s"^TimeString);

					if (Net_CheckpointRank == 1) {
						Label_Rank.Value = "{{{_("1st")}}}";
					} else if (Net_CheckpointRank == 2) {
						Label_Rank.Value = "{{{_("2nd")}}}";
					} else if (Net_CheckpointRank == 3) {
						Label_Rank.Value = "{{{_("3rd")}}}";
					} else if (Net_CheckpointRank > 3) {
						Label_Rank.Value = TextLib::Compose("{{{_("%1th")}}}", TextLib::ToText(Net_CheckpointRank));
					} else {
						Label_Rank.Value = "";
					}

					ShowTimeDiff = True;
					Frame_TimeDiff.Show();

					if (Net_RespawnCount >= 0) {
						Quad_Medal.Visible = True;
						if (Net_RespawnCount <= {{{C_Medal_Gold}}}) {
							Quad_Medal.Substyle = "MedalGold";
						} else if (Net_RespawnCount <= {{{C_Medal_Silver}}}) {
							Quad_Medal.Substyle = "MedalSilver";
						} else if (Net_RespawnCount <= {{{C_Medal_Bronze}}}) {
							Quad_Medal.Substyle = "MedalBronze";
						} else {
							Quad_Medal.Visible = False;
						}
						declare RespawnText = "respawn";
						if (Net_RespawnCount > 1) RespawnText = "respawns";
						Label_Medal.Value = TextLib::Compose("%1 %2", TextLib::ToText(Net_RespawnCount), RespawnText);
						Frame_Medal.Visible = True;
					} else {
						Frame_Medal.Visible = False;
					}
				}
			}
		}
	--></script>
	<frame id="{{{C_Module_TimeDiff}}}" class="LibCustomUI_Module">
		<frame id="Frame_TimeDiff" posn="0 65 10">
			<label id="Label_Rank" posn="0 6" halign="center" valign="center2" textemboss="1"/>
			<label id="Label_Time" posn="-0.5 0" scale="1.5" halign="right" valign="center2"/>
			<label id="Label_Diff" posn="0.5 0" scale="1.1" halign="left" valign="center2"/>
			<frame id="Frame_Medal" posn="-7 -10" hidden="1">
				<quad sizen="10 10" halign="right" valign="center2" style="MedalsBig" substyle="MedalBronze" id="Quad_Medal" />
				<label posn="1 0" valign="center" textemboss="1" id="Label_Medal" />
			</frame>
		</frame>
	</frame>
</manialink>""";
}

// Update the timediff manialink
Void UpdateLayerTimeDiff(CSmPlayer _Player, Integer _Time1, Integer _Time2, Integer _Rank, Integer _RespawnCount) {
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;
	declare netwrite Net_LayerTimeDiffUpdated for UI = 0;
	declare netwrite Net_Time1 for UI = 0;
	declare netwrite Net_Time2 for UI = 0;
	declare netwrite Net_CheckpointRank for UI = 0;
	declare netwrite Net_RespawnCount for UI = -1;
	Net_LayerTimeDiffUpdated = Now;
	Net_Time1 = _Time1;
	Net_Time2 = _Time2;
	Net_CheckpointRank = _Rank;
	Net_RespawnCount = _RespawnCount;
}

// Update custom score 1 for the given player
Void UpdateCustom1(CSmPlayer _Player, Boolean _Voting) {
	if (_Player == Null) return;
	if (_Voting) {
		ScoresTable::SetCustom1(_Player, " $900x");
	} else {
		ScoresTable::SetCustom1(_Player, "");
	}
}

// Update custom score 2 for the given player
Void UpdateCustom2(CSmPlayer _Player) {
	if (_Player == Null || _Player.Score == Null) return;
	declare BestRespawnCount for _Player.Score = -1;
	if (BestRespawnCount >= 0) {
		ScoresTable::SetCustom2(_Player, TextLib::ToText(BestRespawnCount));
		return;
	} else {
		declare RespawnCount for _Player = -1;
		if (RespawnCount > 0) {
			ScoresTable::SetCustom2(_Player, TextLib::ToText(RespawnCount));
			return;
		}
	}
	ScoresTable::SetCustom2(_Player, "");
}

// Update custom score 3 for the given player
Void UpdateCustom3(CSmPlayer _Player) {
	if (_Player == Null || _Player.Score == Null) return;
	declare RunBest for _Player.Score = -1;
	if (RunBest >= 0) {
		ScoresTable::SetCustom3(_Player, TextLib::TimeToText(RunBest, True));
		return;
	} else {
		declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
		if (CheckpointsTimeLast.count > 0) {
			ScoresTable::SetCustom3(_Player, TextLib::Compose(_("|Checkpoint|CP %1"), TextLib::ToText(CheckpointsTimeLast.count)));
			return;
		}
	}
	ScoresTable::SetCustom3(_Player, "");
}

// Update the footer score for the given player
Void UpdateFooterScore(CSmPlayer _Player) {
	if (_Player == Null) return;
	if (_Player.User.RequestsSpectate) {
		ScoresTable::SetFooterScore(_Player, " ");
	} else {
		declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
		declare RespawnCount for _Player = 0;
		ScoresTable::SetFooterScore(_Player, TextLib::Compose(_("|Progress,Checkpoints,Respawns|Progress: %1/%2 CPs, %3 RS"),
			TextLib::ToText(CheckpointsTimeLast.count), TextLib::ToText(G_CheckpointsTotal), TextLib::ToText(RespawnCount)));
	}
}

// Update the footer stats for the given player
Void UpdateFooterStats(CSmPlayer _Player) {
	if (_Player == Null) return;
	{---UpdateFooterStats---}
}

// Penalize a player
Void AddPenalty(CPlayer _Player, Integer _Duration) {
	if (_Player == Null) return;

	declare Obstacle_Penalty for _Player = 0;
	Obstacle_Penalty += _Duration;

	declare netwrite Net_Obstacle_Penalty for _Player = 0;
	Net_Obstacle_Penalty = Obstacle_Penalty;
}

// Clear the penalty of a player
Void ClearPenalty(CPlayer _Player) {
	if (_Player == Null) return;
	declare Obstacle_Penalty for _Player = 0;
	Obstacle_Penalty = 0;

	declare netwrite Net_Obstacle_Penalty for _Player = 0;
	Net_Obstacle_Penalty = Obstacle_Penalty;
}

// Get the current penalty of a player
Integer GetPenalty(CPlayer _Player) {
	if (_Player == Null) return 0;

	declare Obstacle_Penalty for _Player = 0;
	return Obstacle_Penalty;
}

// Get the current time of a player
Integer GetTime(CPlayer _Player) {
	if (_Player == Null) return 0;

	declare Obstacle_Penalty for _Player = 0;
	declare netwrite Net_StartTime for _Player = 0;
	return (Now - Net_StartTime) + Obstacle_Penalty;
}

// Initialize the given score
Void InitScore(CSmScore _Score, Boolean _FullInit) {
	if (_Score != Null) {
		declare Integer[Ident] CheckpointsTimeLast for _Score;
		CheckpointsTimeLast.clear();

		if (_FullInit) {
			declare Integer RunBest for _Score;
			declare Integer BestRespawnCount for _Score;
			declare Integer[Ident] CheckpointsTimeBest for _Score;

			CheckpointsTimeBest.clear();
			RunBest = -1;
			BestRespawnCount = -1;
			_Score.RoundPoints = 0;
			_Score.Points = 0;
		}
	} else {
		foreach (Score in Scores) {
			InitScore(Score, _FullInit);
		}
	}
}

// Initialize the given player
Void InitPlayer(CSmPlayer _Player, Boolean _FullInit) {
	if (_Player != Null) {
		if (!_FullInit) {
			// Save run progress during spectating
			declare WasSpectator for _Player = False;
			if (_Player.User.RequestsSpectate) {
				WasSpectator = True;
				return;
			} else {
				if (WasSpectator) {
					return;
				}
			}
		} else {
			declare Integer RunLast for _Player;
			RunLast = -1;
		}

		declare netwrite Integer Net_StartTime for _Player;
		declare Integer RespawnCount for _Player;
		declare Ident LastCheckpointId for _Player;
		declare netwrite Boolean UsedJump for _Player;

		Net_StartTime = 0;
		RespawnCount = 0;
		LastCheckpointId = NullId;
		UsedJump = False;
		ClearPenalty(_Player);

		InitScore(_Player.Score, _FullInit);

		ScoresTable::RestoreCustomScores(_Player);
		UpdateCustom2(_Player);
		UpdateCustom3(_Player);
		UpdateFooterScore(_Player);
		UpdateFooterStats(_Player);
	} else {
		foreach (Player in AllPlayers) {
			InitPlayer(Player, _FullInit);
		}
	}
}

// Sets the weapon type
Void ApplyWeaponType(CSmPlayer _Player, Integer _Type) {
	if (_Player == Null) return;
	declare Text UIMessage;
	switch (_Type) {
		case 1: {
			// No ammunition gain
			_Player.AmmoGain = 0.0;
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 0);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 0);
			UIMessage = _("No Ammunition!");
		}
		case 2: {
			// Endless ammunition
			_Player.AmmoGain = 10.0;
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 10);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 10);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 10);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 10);
			UIMessage = ("Endless Ammunition!");
		}
		default: {
			// Default values
			_Player.AmmoGain = 1.0;
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Laser, 1);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Rocket, 4);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Nucleus, 2);
			SetPlayerAmmoMax(_Player, CSmMode::EWeapon::Arrow, 3);
			UIMessage = ("Normal Ammunition!");
		}
	}
	declare LastWeaponType for _Player = 0;
	if (LastWeaponType != _Type) {
		Message::SendStatusMessage(_Player, UIMessage, 3000, 1);
		LastWeaponType = _Type;
	}
}

// Fill up current player ammo
Void FillUpPlayerAmmo(CSmPlayer _Player) {
	if (_Player == Null) return;
	SetPlayerAmmo(_Player, CSmMode::EWeapon::Rocket, 10);
	SetPlayerAmmo(_Player, CSmMode::EWeapon::Laser, 10);
	SetPlayerAmmo(_Player, CSmMode::EWeapon::Nucleus, 10);
	SetPlayerAmmo(_Player, CSmMode::EWeapon::Arrow, 10);
}

// Restart a player
Void RestartPlayer(CSmPlayer _Player, Boolean _FullRestart, Boolean _Jump) {
	if (_Player == Null || _Player.User.RequestsSpectate || _Player.Score == Null) return;
	declare Delay = 3500;
	if (StartTime > Now + Delay) {
		Delay = StartTime - Now;
	}
	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	declare netwrite ItemBuffTimes for _Player = Integer[Text];
	ItemBuffTimes.clear();

	SetPlayerReloadAllWeapons(_Player, S_FullAmmoSpawn);

	if (_Jump || !_FullRestart && CheckpointsTimeLast.count > 0) {
		// Check respawn behavior
		declare UI <=> UIManager.GetUI(_Player);
		declare RespawnOnCheckpoint = True;
		if (UI != Null) {
			declare netread Net_RespawnOnCheckpoint for UI = True;
			RespawnOnCheckpoint = Net_RespawnOnCheckpoint;
		}

		if (UI == Null || RespawnOnCheckpoint) {
			// Respawn at last checkpoint
			declare LastCheckpointId for _Player = NullId;
			declare CPSpawnId = GetClosestSpawn(LastCheckpointId);
			if (MapLandmarks_PlayerSpawn.existskey(CPSpawnId)) {
				// CPSpawn found
				declare RespawnCount for _Player = 0;
				RespawnCount += 1;

				UpdateCustom2(_Player);
				UpdateFooterScore(_Player);

				// Check if the map support fast respawn
				// Above version 2 : yes
				// Below version 2 : only if S_FastRespawnOldMap is True
				declare CanFastRespawn = True;
				if (Map::GetMapTypeVersion() >= 2 && MapLandmarks_Gauge.existskey(LastCheckpointId)) {
					declare metadata DefaultTag for MapLandmarks_Gauge[LastCheckpointId] = "";
					if (DefaultTag != "Checkpoint") CanFastRespawn = False;
				} else if (Map::GetMapTypeVersion() < 2 && !S_FastRespawnOldMap) {
					CanFastRespawn = False;
				}

				// Use fast respawn on checkpoint
				if (S_FastRespawn && _Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && MapLandmarks_Gauge.existskey(LastCheckpointId) && CanFastRespawn) {
					RespawnPlayer(_Player, MapLandmarks_Gauge[LastCheckpointId]);
				}
				// Classic respawn inside the spawn block
				else {
					SM::SpawnPlayer(_Player, 0, MapLandmarks_PlayerSpawn[CPSpawnId].PlayerSpawn, Now + Delay);
				}

				if (S_FullAmmoSpawn) {
					FillUpPlayerAmmo(_Player);
				}

				if (S_RespawnPenalty > 0) {
					AddPenalty(_Player, S_RespawnPenalty * 1000);
				}

				// XmlRpc callback
				XmlRpc.SendCallback("OnRespawn", _Player.User.Login);

				return;
			}
		}
	}

	// FULL RESTART
	declare netwrite Integer Net_StartTime for _Player;
	declare netwrite Integer Net_CPProgress for _Player;
	declare RespawnCount for _Player = 0;
	declare LastCheckpointId for _Player = NullId;
	declare netwrite Boolean Net_UsedJump for _Player;

	// Spawn player
	if (MapLandmarks_PlayerSpawn.existskey(G_StartSpawnId)) {
		declare SpawnLandmark <=> MapLandmarks_PlayerSpawn[G_StartSpawnId];

		// Set weapon type
		declare WeaponType = 0;
		declare SpawnName = SpawnLandmark.Tag;
		if (TextLib::Length(SpawnName) > 5) {
			WeaponType = TextLib::ToInteger(TextLib::SubString(SpawnName, 9, 1));
		}
		ApplyWeaponType(_Player, WeaponType);

		SM::SpawnPlayer(_Player, 0, SpawnLandmark.PlayerSpawn, Now + Delay);
		if (S_FullAmmoSpawn) {
			FillUpPlayerAmmo(_Player);
		}
	} else {
		UnspawnPlayer(_Player);
	}

	// Update values
	CheckpointsTimeLast.clear();
	Net_StartTime = _Player.StartTime;
	RespawnCount = 0;
	LastCheckpointId = NullId;
	Net_CPProgress = CheckpointsTimeLast.count;
	Net_UsedJump = False;
	ClearPenalty(_Player);

	// Reset missing checkpoints
	UpdatePoleIds(_Player);

	// UI
	UpdateCustom2(_Player);
	UpdateCustom3(_Player);
	UpdateFooterScore(_Player);

	// XmlRpc callback
	XmlRpc.SendCallback("OnRestart", _Player.User.Login);
}

// Teleport a player to a checkpoint
Void JumpToCheckpoint(CSmPlayer _Player, Integer _Target) {
	if (_Player == Null || _Target < 0) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;

	if (!S_AllowJump) {
		UI.SendChat("$f00Jumping is disabled!");
		return;
	}

	declare Ident LastCheckpointId as PlayerCPId for _Player;

	// Jump to checkpoint
	declare CSmMapLandmark Target <=> Null;
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		if (!IsCheckpoint(GaugeLandmark)) continue;
		if (GaugeLandmark.Order != _Target) continue;
		Target <=> GaugeLandmark;
		break;
	}
	if (Target == Null) {
		declare PoleIndex = 0;
		foreach (GaugeLandmark in MapLandmarks_Gauge) {
			if (!IsCheckpoint(GaugeLandmark)) continue;
			if (PoleIndex == _Target) {
				Target <=> GaugeLandmark;
				break;
			}
			PoleIndex += 1;
		}
	}
	if (Target == Null) {
		// Invalid pole
		UI.SendChat("$f00Invalid Checkpoint Index '"^_Target^"'!");
		return;
	}
	// Jump
	UI.SendChat("$0f0Jumping to Checkpoint '"^_Target^"'!");
	PlayerCPId = Target.Id;
	RestartPlayer(_Player, False, True);

	// Invalidate time
	declare netwrite Boolean Net_UsedJump for _Player;
	Net_UsedJump = True;
}

// Create utility layer manialink
Text CreateLayerUtilities() {
	declare Manialink = """
<manialink version="1" name="Obstacle_LayerUtilities">
	<script><!--
		#Include "TextLib" as TextLib

		#Const	C_UseNextMapVoting	{{{(S_NextMapVotingRatio > 0.0 && S_NextMapVotingRatio <= 1.0)}}}
		#Const	C_IgnoredRestartKey	["Tab", "Goto"]

		main() {
			wait(InputPlayer != Null && UI != Null && Page != Null);

			declare Frame_SpectateCount <=> (Page.GetFirstChild("Frame_SpectateCount") as CMlFrame);
			declare Label_SpectateCount <=> (Frame_SpectateCount.GetFirstChild("Label_SpectateCount") as CMlLabel);
			declare Quad_Spec <=> (Page.GetFirstChild("Quad_Spec") as CMlQuad);

			declare Label_Jumped <=> (Page.GetFirstChild("Label_Jumped") as CMlLabel);
			declare Label_CPProgress <=> (Page.GetFirstChild("Label_CPProgress") as CMlLabel);
			declare Label_RespawnBehavior <=> (Page.GetFirstChild("Label_RespawnBehavior") as CMlLabel);
			declare Label_NextMapVoting <=> (Page.GetFirstChild("Label_NextMapVoting") as CMlLabel);

			Label_Jumped.Value = _("You used a Jump! Your Time is invalid.");

			// CP count
			declare netread Net_CheckpointsTotal for Teams[0] = -1;

			// Respawn behavior
			declare netwrite Net_RespawnOnCheckpoint for UI = True;
			Label_RespawnBehavior.Value = TextLib::Compose("$f00%1", _("Respawning deactivated!"));""";
	if (!G_Solo) {
		Manialink ^= """
			// Next map voting
			// Values: 1 - Next, 2 - Stay
			declare netwrite Net_NextMapVote for UI = 0;

			declare netread Net_NextMapVotingReset for UI = 0;
			declare LastNextMapVotingReset = -1;
			declare netread Net_PlayersVotingNext for Teams[0] = 0;
			declare netread Net_PlayersTotal for Teams[0] = 0;
			declare netread Net_PlayersVotingRemaining for Teams[0] = 0;

			// Spec target
			declare netwrite Net_SpecTargetLogin for UI = "";
			declare netwrite Net_SpeccedTargetLogin for UI = "";""";
	}
	Manialink ^= """
			// Custom restarting
			declare Label_Choose <=> (Page.GetFirstChild("Label_Choose") as CMlLabel);
			Label_Choose.Visible = True;
			declare netwrite Net_CustomRestartTime for UI = 0;
			declare OwnCustomRestartKey for UI = "Delete";
			declare ChoosingRestartKey = False;

			declare LastUIUpdate = 0;

			{{{CustomUI::InjectMLInit()}}}

			while (True) {
				yield;

				declare LocalPlayer <=> InputPlayer;
				if (GUIPlayer != Null) LocalPlayer <=> GUIPlayer;""";
	if (!G_Solo) {
		Manialink ^= """
				// Spec count
				declare _TabsLib_ScoresLayerIsVisible for UI = False;
				declare _TabsLib_AltLayerIsVisible for UI = False;
				Frame_SpectateCount.Visible = (_TabsLib_ScoresLayerIsVisible || _TabsLib_AltLayerIsVisible);
				if (Frame_SpectateCount.Visible) {
					declare netread Net_NbSpectating for LocalPlayer = 0;
					Label_SpectateCount.Value = TextLib::ToText(Net_NbSpectating);
				}

				// Check for next map voting reset
				if (Net_NextMapVotingReset != LastNextMapVotingReset) {
					Net_NextMapVote = 0;
					LastNextMapVotingReset = Net_NextMapVotingReset;
				}""";
	}
	Manialink ^= """
				// Process events
				foreach (Event in PendingEvents) {
					switch (Event.Type) {
						case CMlEvent::Type::KeyPress: {
							if (ChoosingRestartKey) {
								ChoosingRestartKey = False;
								if (!C_IgnoredRestartKey.exists(Event.KeyName)) {
									OwnCustomRestartKey = Event.KeyName;
									continue;
								}
							}
							switch (Event.KeyName) {
								case OwnCustomRestartKey: {
									// Restart requested
									Net_CustomRestartTime = ArenaNow;
								}
							}
							switch (Event.CharPressed) {""";
	if (!G_Solo) {
		Manialink ^= """		case "2621440": {
									// F3 - Change next map vote
									if (C_UseNextMapVoting) {
										if (Net_NextMapVote == 1) {
											Net_NextMapVote = 0;
										} else {
											Net_NextMapVote = 1;
										}
									}
								}""";
	}
	Manialink ^= """			case "2686976": {
									// F4 - Change respawn behavior
									Net_RespawnOnCheckpoint = !Net_RespawnOnCheckpoint;
								}
							}
						}
						case CMlEvent::Type::MouseClick: {
							switch (Event.ControlId) {
								case "Label_Choose": {
									ChoosingRestartKey = !ChoosingRestartKey;
								}
								case "Quad_Spec": {
									declare netwrite Integer Net_SpecTargetChanged for UI;
									declare netwrite Text Net_SpecTargetLogin for UI;
									Net_SpecTargetChanged = Now;
									Net_SpecTargetLogin = "";
								}
							}
						}
					}
				}

				if (LastUIUpdate + 400 > Now) continue;
				LastUIUpdate = Now;

				// Custom spec button
				Quad_Spec.Visible = UI.ForceSpectator;

				// Jumped label
				declare netread Net_UsedJump for LocalPlayer = False;
				Label_Jumped.Visible = Net_UsedJump;

				// CP progress
				declare netread Net_StartTime for LocalPlayer = -1;
				declare netread Net_CPProgress for LocalPlayer = -1;
				if (Net_CPProgress < 0 || Net_CheckpointsTotal < 0 || Net_StartTime < 0) {
					Label_CPProgress.Visible = False;
				} else {
					Label_CPProgress.Visible = True;
					Label_CPProgress.Value = TextLib::Compose("%1: %2/%3", _("|Progress on checkpoints|CP Progress"),
						TextLib::ToText(Net_CPProgress), TextLib::ToText(Net_CheckpointsTotal));
				}

				// Respawn behavior
				if (LocalPlayer != InputPlayer && InputPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					declare netread Net_ShowRespawnBehavior for LocalPlayer = False;
					Label_RespawnBehavior.Visible = Net_ShowRespawnBehavior;
				} else {
					Label_RespawnBehavior.Visible = !Net_RespawnOnCheckpoint;
				}""";
	if (!G_Solo) {
		Manialink ^= """
				// Spec target
				if (LocalPlayer.Login != InputPlayer.Login) {
					Net_SpeccedTargetLogin = LocalPlayer.Login;
				} else {
					Net_SpeccedTargetLogin = "";
				}

				// Next map voting label
				if (C_UseNextMapVoting) {
					Label_NextMapVoting.Visible = True;

					declare Text Color;
					declare Text VotingText;
					if (Net_NextMapVote == 1) {
						Color = "$0C0";
						VotingText = _("Press F3 for keeping the map");
					} else {
						Color = "$080";
						VotingText = _("Press F3 to vote for the next map");
					}

					declare Remaining = Net_PlayersVotingNext^"/"^Net_PlayersTotal;
					if (Net_PlayersVotingRemaining > 0) {
						Remaining ^= " (-"^Net_PlayersVotingRemaining^")";
					}

					Label_NextMapVoting.Value = TextLib::Compose("%1%2: %3", Color, VotingText, Remaining);
				} else {
					Label_NextMapVoting.Visible = False;
				}""";
	}
	Manialink ^= """
				// Restart key
				if (ChoosingRestartKey) {
					Label_Choose.Value = _("Press your Key...");
				} else {
					Label_Choose.Value = TextLib::Compose("%1: %2", _("|Restart a run|Restart"), OwnCustomRestartKey);
				}

				{{{CustomUI::InjectMLLoop()}}}
			}
		}
	--></script>
	<label id="Label_Jumped" posn="50 -66" textsize="1" textprefix="$f00" translate="1" halign="center" valign="center2" hidden="1"/>
	<quad id="Quad_Spec" posn="-57 -54.5" sizen="12 12" style="UIConstruction_Buttons" substyle="Camera" scriptevents="1"
		halign="center" valign="center2" hidden="1"/>
	<frame id="{{{C_Module_CPProgress}}}" class="LibCustomUI_Module">
		<label id="Label_CPProgress" posn="-47 -78" sizen="40 5" textsize="1" translate="1" halign="center" valign="center2" hidden="1"/>
	</frame>
	<frame id="{{{C_Module_RespawnBehavior}}}" class="LibCustomUI_Module">
		<label id="Label_RespawnBehavior" posn="-20 88" sizen="40 4" textsize="1" translate="1" halign="right" valign="center2" hidden="1"/>
	</frame>
	<frame id="{{{C_Module_NextMapVoting}}}" class="LibCustomUI_Module">
		<label id="Label_NextMapVoting" posn="20 88" sizen="60 4" textsize="1" translate="1" halign="left" valign="center2" hidden="1"/>
	</frame>
	<frame id="{{{C_Module_SpectateCount}}}" class="LibCustomUI_Module">
		<frame id="Frame_SpectateCount" posn="159 -63" hidden="1">
			<quad sizen="8 8" style="BgRaceScore2" substyle="Tv" halign="right" valign="center2"/>
			<label id="Label_SpectateCount" posn="-9 0" sizen="15 8" style="TextTitle1" textsize="3" text="0" halign="right" valign="center2"/>
		</frame>
	</frame>
	<frame id="{{{C_Module_RestartKey}}}" class="LibCustomUI_Module">
		<label id="Label_Choose" posn="95 -87" halign="center" valign="center2" scale="0.7" style="CardButtonSmall" scriptevents="1" hidden="1"/>
	</frame>
</manialink>""";
	return Manialink;
}

// Update the utitilies layer
Void UpdateLayerUtilities() {
	// Respawn stuff
	foreach (Player in Players) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;

		// Check for full restarts
		declare LastCustomRestartTime for Player = 0;
		declare netread Net_CustomRestartTime for UI = 0;
		if (Net_CustomRestartTime > LastCustomRestartTime) {
			LastCustomRestartTime = Net_CustomRestartTime;
			RestartPlayer(Player, True, False);
		}

		// Publish respawn behavior
		declare netread Net_RespawnOnCheckpoint for UI = True;
		declare netwrite Net_ShowRespawnBehavior for Player = False;
		Net_ShowRespawnBehavior = !Net_RespawnOnCheckpoint;
	}

	// Update custom spec and jump stuff
	foreach (Player in AllPlayers) {
		declare netwrite Integer Net_NbSpectating for Player;
		Net_NbSpectating = 0;

		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;

		// Custom spec
		declare ForceSpec = False;
		declare SpecTarget = NullId;

		declare Last_SpecTargetChanged for UI = -1;
		declare netread Net_SpecTargetChanged for UI = -1;
		if (Last_SpecTargetChanged != Net_SpecTargetChanged) {
			declare Last_SpecTargetLogin for UI = "";
			declare netread Net_SpecTargetLogin for UI = "";
			if (CanFreeSpec(Player) && Net_SpecTargetLogin != Player.User.Login && Net_SpecTargetLogin != "") {
				if (!UI.ForceSpectator || Last_SpecTargetLogin != Net_SpecTargetLogin) {
					ForceSpec = True;
					foreach (ThisPlayer in Players) {
						if (ThisPlayer.User.Login == Net_SpecTargetLogin) {
							SpecTarget = ThisPlayer.Id;
							break;
						}
					}
				}
			}

			if (!Players.existskey(SpecTarget)) {
				ForceSpec = False;
				SpecTarget = NullId;
			}

			Last_SpecTargetChanged = Net_SpecTargetChanged;
			Last_SpecTargetLogin = Net_SpecTargetLogin;

			UI.ForceSpectator = ForceSpec;
			UI.SpectatorForcedTarget = SpecTarget;
			UI.SpectatorAutoTarget = SpecTarget;
		}
	}

	// Multiplayer stuff
	if (!G_Solo) {
		declare SpeccedPlayers = Integer[Text];

		declare PlayersNb = Players.count;
		declare VotingsNb = 0;
		foreach (Player in AllPlayers) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI == Null) continue;

			// Spec counts
			declare netread Net_SpeccedTargetLogin for UI = "";
			if (Net_SpeccedTargetLogin != "") {
				if (!SpeccedPlayers.existskey(Net_SpeccedTargetLogin)) {
					SpeccedPlayers[Net_SpeccedTargetLogin] = 1;
				} else {
					SpeccedPlayers[Net_SpeccedTargetLogin] += 1;
				}
			}

			// Collect current voting
			declare netread Net_NextMapVote for UI = 0;
			if (Net_NextMapVote == 1) {
				VotingsNb += 1;
			}
			UpdateCustom1(Player, (Net_NextMapVote == 1));
		}
		declare Remaining = MathLib::CeilingInteger(PlayersNb * S_NextMapVotingRatio) - VotingsNb;

		// Push update
		declare netwrite Integer Net_PlayersTotal for Teams[0];
		declare netwrite Integer Net_PlayersVotingNext for Teams[0];
		declare netwrite Integer Net_PlayersVotingRemaining for Teams[0];
		Net_PlayersTotal = PlayersNb;
		Net_PlayersVotingNext = VotingsNb;
		Net_PlayersVotingRemaining = Remaining;

		foreach (PlayerLogin => NbSpectating in SpeccedPlayers) {
			declare Player <=> Tools::GetPlayer(PlayerLogin);
			if (Player == Null) continue;
			declare netwrite Integer Net_NbSpectating for Player;
			Net_NbSpectating = NbSpectating;
		}

		// End map?
		if (PlayersNb > 0 && VotingsNb > 0 && Remaining <= 0 && StartTime + 15000 < Now && EndTime - 15000 > Now) {
			Message::SendStatusMessage(_("Voting has forced an End of the current Map."), 5000, 1);
			EndTime = Now + 15000;
		}
	}
}

// Update the auto target for spectators
Void UpdateAutoTarget(Ident _SpecTargetId) {
	declare LastAutoSpecSwitch for This = -1;
	if (LastAutoSpecSwitch > Now - 8000) return;
	LastAutoSpecSwitch = Now;

	foreach (Spectator in Spectators) {
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI == Null) continue;
		UI.SpectatorAutoTarget = _SpecTargetId;
	}
}

// Player enters portal
Void UsePortal(CSmPlayer _Player, Ident _PoleId) {
	if (_Player == Null || !MapLandmarks_Gauge.existskey(_PoleId)) return;
	declare SpawnId = GetClosestSpawn(_PoleId);
	if (!MapLandmarks_PlayerSpawn.existskey(SpawnId)) return;

	// Portal exit found - Port player
	SM::SpawnPlayer(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);

	// Send message
	declare LastStatusMessage for _Player = 0;
	if (LastStatusMessage + 2500 >= Now) return;
	LastStatusMessage = Now;
	Message::SendBigMessage(_Player, _("Portal!"), 2500, 0);
}

// A player reaches a checkpoint
Void ActivateCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
	if (_Player == Null || _Player.Score == Null || !MapLandmarks_Gauge.existskey(_CheckpointId)) return;
	declare CheckpointsTimeLast for _Player.Score = Integer[Ident];
	declare GaugeLandmark <=> MapLandmarks_Gauge[_CheckpointId];
	if (CheckpointsTimeLast.existskey(_CheckpointId) || (GaugeLandmark.Order != 0 && GaugeLandmark.Order != CheckpointsTimeLast.count + 1)) return;
	declare LastCheckpointId for _Player = NullId;
	declare netwrite Integer Net_CPProgress for _Player;

	CheckpointsTimeLast[_CheckpointId] = GetTime(_Player);
	declare TimeDiff = CheckpointsTimeLast[_CheckpointId];
	if (CheckpointsTimeLast.existskey(LastCheckpointId)) {
		TimeDiff -= CheckpointsTimeLast[LastCheckpointId];
	}
	declare NewBest = CPTimes::SubmitCheckpointTime(CheckpointsTimeLast.count, _Player, TimeDiff);
	if (NewBest || MathLib::Rand(0, 11) == 5) {
		UpdateAutoTarget(_Player.Id);
	}

	LastCheckpointId = _CheckpointId;
	Net_CPProgress = CheckpointsTimeLast.count;

	// Update missing checkpoints
	UpdatePoleIds(_Player);

	UpdateCustom3(_Player);
	UpdateFooterScore(_Player);
	UpdateRanking();

	// Special checkpoints
	declare CheckpointName = GaugeLandmark.Tag;
	if (TextLib::Length(CheckpointName) > 10) {
		declare TypeString = TextLib::SubString(CheckpointName, 14, 1);
		switch (TypeString) {
			case "3": {
				// Portal
				UsePortal(_Player, _CheckpointId);
			}
			default: {
				// Special weapon checkpoints
				ApplyWeaponType(_Player, TextLib::ToInteger(TypeString));
			}
		}
	} else {
		// Default checkpoints
		ApplyWeaponType(_Player, 0);
	}

	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null && _Player.Score != Null) {
		declare CheckpointsTimeBest for _Player.Score = Integer[Ident];
		declare TimeDiffStartTime for UI = 0;
		declare BestTime = -1;

		if (CheckpointsTimeBest.existskey(_CheckpointId)) {
			BestTime = CheckpointsTimeBest[_CheckpointId];
		}
		TimeDiffStartTime = Now;

		// Find player ranking at checkpoint
		declare Rank = 1;
		declare Ranking = Integer[Ident];
		foreach (Score in Scores) {
			declare CheckpointsTimeBest as OpponentCheckpointsTimeBest for Score = Integer[Ident];
			if (Score.User.Id == _Player.User.Id || !OpponentCheckpointsTimeBest.existskey(_CheckpointId)) continue;
			Ranking[Score.User.Id] = OpponentCheckpointsTimeBest[_CheckpointId];
		}
		Ranking[_Player.User.Id] = CheckpointsTimeLast[_CheckpointId];
		Ranking = Ranking.sort();
		foreach (UserId => CheckpointTime in Ranking) {
			if (UserId == _Player.User.Id) break;
			Rank += 1;
		}

		UpdateLayerTimeDiff(_Player, CheckpointsTimeLast[_CheckpointId], BestTime, Rank, -1);

		declare Color = "$00f";
		declare Variant = 0;

		if (BestTime > -1 && CheckpointsTimeLast[_CheckpointId] > BestTime) {
			Color = "$f00";
			Variant = 1;
		}

		UI.SendNotice(TextLib::Compose("%1 %2/%3: $<%4$>", _("Checkpoint"),
			TextLib::ToText(CheckpointsTimeLast.count), TextLib::ToText(G_CheckpointsTotal),
			Color^TextLib::TimeToText(CheckpointsTimeLast[_CheckpointId], True)),
			CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Checkpoint, Variant);
	}

	// XmlRpc callback
	SendXmlRpcCallback("OnCheckpoint", _Player, CheckpointsTimeLast[_CheckpointId], _CheckpointId);
}

// Check if a notice for a medal time should be sent
Boolean ShowNotice(CSmPlayer _Player, CMode::EMedal _Medal) {
	if (_Player == Null || _Player.Score == Null || G_Solo) return False;
	declare BestMedal for _Player.Score = CMode::EMedal::Finished;
	if (BestMedal == CMode::EMedal::Author) return False;
	switch (_Medal) {
		case CMode::EMedal::Author: {
			BestMedal = _Medal;
			return True;
		}
		case CMode::EMedal::Gold: {
			if (BestMedal == CMode::EMedal::Author || BestMedal == CMode::EMedal::Gold) return False;
			BestMedal = _Medal;
			return True;
		}
		case CMode::EMedal::Silver: {
			if (BestMedal != CMode::EMedal::Finished && BestMedal == CMode::EMedal::Bronze) return False;
			BestMedal = _Medal;
			return True;
		}
		case CMode::EMedal::Bronze: {
			if (BestMedal != CMode::EMedal::Finished) return False;
			BestMedal = _Medal;
			return True;
		}
	}
	return False;
}

// Calculate reached medal and build message
Text[] MedalFromRunNew(CSmPlayer _Player) {
	declare Text[] Messages;
	if (_Player == Null) return Messages;
	declare CMode::EMedal Medal;
	declare RunLast for _Player = -1;
	if (RunLast > 0) {
		declare metadata ObjectiveAuthor for Map = -1;
		declare metadata ObjectiveGold for Map = -1;
		declare metadata ObjectiveSilver for Map = -1;
		declare metadata ObjectiveBronze for Map = -1;

		if (RunLast <= ObjectiveAuthor && ObjectiveAuthor > 0) {
			Medal = CMode::EMedal::Author;
			Messages.add(_("You won the Author Medal!"));
			if (ShowNotice(_Player, Medal)) Messages.add(TextLib::Compose(_("%1 won the Author Medal!"), "$<"^_Player.User.Name^"$>"));
		} else if (RunLast <= ObjectiveGold && ObjectiveGold > 0) {
			Medal = CMode::EMedal::Gold;
			Messages.add(_("You won the Gold Medal!"));
			if (ShowNotice(_Player, Medal)) Messages.add(TextLib::Compose(_("%1 won the Gold Medal!"), "$<"^_Player.User.Name^"$>"));
		} else if (RunLast <= ObjectiveSilver && ObjectiveSilver > 0) {
			Medal = CMode::EMedal::Silver;
			Messages.add(_("You won the Silver Medal!"));
			if (ShowNotice(_Player, Medal)) Messages.add(TextLib::Compose(_("%1 won the Silver Medal!"), "$<"^_Player.User.Name^"$>"));
		} else if (RunLast <= ObjectiveBronze && ObjectiveBronze > 0) {
			Medal = CMode::EMedal::Bronze;
			Messages.add(_("You won the Bronze Medal!"));
			if (ShowNotice(_Player, Medal)) Messages.add(TextLib::Compose(_("%1 won the Bronze Medal!"), "$<"^_Player.User.Name^"$>"));
		} else {
			Medal = CMode::EMedal::Finished;
			Messages.add(_("You finished the Map!"));
		}
		if (_Player.Score != Null) {
			Solo_SetNewRecord(_Player.Score, Medal);
		}
	}
	return Messages;
}

// A player reaches the finish
Void ActivateFinish(CSmPlayer _Player, Ident _GoalId) {
	if (_Player == Null || _Player.Score == Null) return;

	// Jump check
	declare netwrite Net_UsedJump for _Player = False;
	if (Net_UsedJump) {
		declare LastJumpedMessage for _Player = -1;
		if (LastJumpedMessage + 9000 < Now) {
			LastJumpedMessage = Now;
			Message::SendStatusMessage(_Player, TextLib::Compose("$f00%1", _("You used a Jump! Your Time is invalid.")), 4000, 0);
		}
		return;
	}

	// Perform finish
	---PlayerFinish---
}

// Manage afk players
Void ManageAfkPlayers() {
	declare Last_AFKCheck for This = -1;
	if (!S_ManageAfkPlayers || Last_AFKCheck + 30000 > Now) return;
	Last_AFKCheck = Now;

	foreach (Player in Players) {
		if (Player.Score == Null) continue;
		declare IsAFK = AFK::IsAFK(Player, 300000, 30000);
		if (!IsAFK) continue;
		declare CheckpointsTimeLast for Player.Score = Integer[Ident];
		if (CheckpointsTimeLast.count > 1) continue;
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null) continue;
		UI.SendNotice(_("You are inactive! Switching into spec..."),
			CUIConfig::ENoticeLevel::PlayerInfo, Null, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Silence, 0);
		Users_RequestSwitchToSpectator(Player.User);
	}
}

// Get the rankings for xmlrpc callback
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		declare RunBest for Score = -1;
		if (RunBest <= 0) continue;
		PlayerList ^= Score.User.Login^":"^RunBest^";";
	}
	return PlayerList;
}

// Create manialink for items layer
Text CreateLayerItems() {
	declare ItemCount = G_ItemIdents.count;
	declare Manialink = """
<manialink version="1" name="Obstacle_LayerItems">
	<script><!--
		#Include "MathLib" as MathLib
		#Include "TextLib" as TextLib

		#Const	C_ItemCount		{{{ItemCount}}}

		main() {
			wait(InputPlayer != Null && Page != Null && LocalUser != Null);

			declare Label_Info <=> (Page.GetFirstChild("Label_Info") as CMlLabel);

			declare Last_UIUpdate = 0;
			declare Last_LabelInfoShown = 0;
			declare Last_BuffEnds = Integer[Text];
			declare Last_BuffDurations = Integer[Text];

			{{{CustomUI::InjectMLInit()}}}

			while (True) {
				yield;

				if (!PageIsVisible || Last_UIUpdate + 50 > Now) continue;
				Last_UIUpdate = Now;

				declare LocalPlayer <=> InputPlayer;
				if (GUIPlayer != Null && GUIPlayer != LocalPlayer) LocalPlayer <=> GUIPlayer;

				declare Index = 1;
				declare netread ItemBuffTimes for LocalPlayer = Integer[Text];
				if (LocalPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
					foreach (ItemName => BuffTime in ItemBuffTimes) {
						declare Frame <=> (Page.GetFirstChild("Frame_ItemGauge"^Index) as CMlFrame);
						if (Frame == Null) continue;
						if (BuffTime < ArenaNow) continue;

						declare Gauge_Item <=> (Frame.GetFirstChild("Gauge_Item") as CMlGauge);
						declare Label_Time <=> (Frame.GetFirstChild("Label_Time") as CMlLabel);
						declare Label_Item <=> (Frame.GetFirstChild("Label_Item") as CMlLabel);

						Index += 1;
						Frame.Visible = True;

						// Adjust Frame Y
						declare Source_Y for Frame = -1000.;
						if (Source_Y <= -1000.) Source_Y = Frame.AbsolutePosition.Y;
						if (LocalPlayer != InputPlayer) {
							Frame.RelativePosition.Y = Source_Y + 15.;
						} else {
							Frame.RelativePosition.Y = Source_Y;
						}

						if (!Last_BuffEnds.existskey(ItemName) || Last_BuffEnds[ItemName] != BuffTime || !Last_BuffDurations.existskey(ItemName)) {
							Last_BuffEnds[ItemName] = BuffTime;
							Last_BuffDurations[ItemName] = BuffTime - ArenaNow;
						}

						declare TimeDiff = BuffTime - ArenaNow;

						declare Ratio = TimeDiff / MathLib::ToReal(Last_BuffDurations[ItemName]);
						if (Ratio < 0.) {
							Ratio = 0.;
						} else if (Ratio > 1.) {
							Ratio = 1.;
						}
						Gauge_Item.Ratio = Ratio;

						declare TimeDiffText = MathLib::NearestInteger(TimeDiff / 100.) / 10.;
						Label_Time.Value = TimeDiffText^"s";

						declare ItemParts = TextLib::Split("\\", ItemName);
						ItemParts = TextLib::Split(".", ItemParts[ItemParts.count-1]);
						Label_Item.Value = ItemParts[0];

						if (LocalPlayer != InputPlayer || Label_Info.Visible) continue;

						declare Obstacle_ItemInfoShown for LocalUser = Integer[Text];
						if (!Obstacle_ItemInfoShown.existskey(ItemName) || Obstacle_ItemInfoShown[ItemName] < 5) {
							if (!Obstacle_ItemInfoShown.existskey(ItemName)) Obstacle_ItemInfoShown[ItemName] = 0;
							Obstacle_ItemInfoShown[ItemName] += 1;
							Last_LabelInfoShown = Now;
							Label_Info.Value = TextLib::Compose(_("You picked up the %1 Item!"), ItemParts[0]);
						}
					}
				}
				for (ExtraIndex, Index, C_ItemCount) {
					declare Frame <=> (Page.GetFirstChild("Frame_ItemGauge"^ExtraIndex) as CMlFrame);
					if (Frame == Null) continue;
					Frame.Visible = False;
				}
				Label_Info.Visible = (Last_LabelInfoShown + 7500 > Now);

				{{{CustomUI::InjectMLLoop()}}}
			}
		}
	--></script>
	<frame id="{{{C_Module_ItemsInfo}}}" class="LibCustomUI_Module">
		<label id="Label_Info" posn="0 40" sizen="110 10" translate="1" halign="center" valign="center2" hidden="1" text="hi"/>
	</frame>
	<frame id="{{{C_Module_Items}}}" class="LibCustomUI_Module">
		<framemodel id="Model_ItemGauge">
			<gauge id="Gauge_Item" sizen="80 14" color="1c6b" style="EnergyBar" drawbg="0" drawblockbg="1" halign="center" valign="center2"/>
			<label id="Label_Time" posn="0 -0.5" style="TextTitle1" textsize="2" halign="center" valign="center2"/>
			<label id="Label_Item" posn="-36.5 -0.5" style="TextTitle1" textsize="1" translate="1" halign="left" valign="center2"/>
		</framemodel>""";
	for (Index, 1, ItemCount) {
		Manialink ^= """<frameinstance id="Frame_ItemGauge{{{Index}}}" posn="0 {{{-65 + Index * 8.3}}} -15" modelid="Model_ItemGauge" hidden="1"/>""";
	}
	Manialink ^= """
	</frame>
</manialink>""";
	return Manialink;
}

// Check minimap library events
Void CheckMiniMapEvents() {
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;

		// Hide ui for minimap
		declare MiniMap_ShowingMap for Player = False;
		Tabs::SetDefaultAltMenuActive(!MiniMap_ShowingMap, Player.User.Login);

		// Switch forced spec
		declare MiniMap_LastClickEvent for Player = -1;
		declare OldLastClickEvent for Player = -1;
		if (OldLastClickEvent != MiniMap_LastClickEvent) {
			OldLastClickEvent = MiniMap_LastClickEvent;
			declare MiniMap_ClickEventData for Player = "";
			declare Target = Tools::GetFromId(MiniMap_ClickEventData);
			if (Target != Null) {
				UI.ForceSpectator = True;
				UI.SpectatorForcedTarget = Target.Id;
				UI.SpectatorAutoTarget = Target.Id;
			} else if (CanFreeSpec(Player)) {
				declare TargetPlayer = Tools::GetPlayer(MiniMap_ClickEventData);
				if (TargetPlayer != Null) {
					UI.ForceSpectator = True;
					UI.SpectatorForcedTarget = TargetPlayer.Id;
					UI.SpectatorAutoTarget = TargetPlayer.Id;
				}
			}
		}

		// Switch camera type
		if (UI.ForceSpectator) {
			declare netread Integer Net_CameraType for UI = 0;
			UI.SpectatorForceCameraType = Net_CameraType;
		}
	}
}
