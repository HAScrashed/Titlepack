#Include "Libs/smokegun/Constants.Script.txt" as C
#Include "Libs/ahmad3/InnerEventAPI.Script.txt" as EventAPI
#Include "Libs/ahmad3/EventAPITypes.Script.txt" as Types

declare Types::K_EventEditionDetails G_Event;
declare Boolean G_EventLoaded;

declare Text G_EventHandle;
declare Integer G_EventEdition;

/**
 * Used to force the non-use of an event, because of a failure somewhere.
 */
declare Boolean G_ForceClear;
declare Text G_LastEventHandle;
declare Integer G_LastEventEdition;

Text GetEventHandle() {
    return G_EventHandle;
}
Void SetEventHandle(Text _EventHandle) {
    G_EventHandle = _EventHandle;
}

Integer GetEventEdition() {
    return G_EventEdition;
}
Void SetEventEdition(Integer _EventEdition) {
    G_EventEdition = _EventEdition;
}

Boolean HasForcedClear() {
    return G_ForceClear;
}

Void ClearSelectedEvent(Boolean _Force) {
    G_ForceClear = _Force;
    G_LastEventHandle = G_EventHandle;
    G_LastEventEdition = G_EventEdition;
    G_EventHandle = "";
    G_EventEdition = -1;
}

Void ClearSelectedEvent() {
    ClearSelectedEvent(False);
}

Types::K_EventEditionDetails CurrentEdition() {
    return G_Event;
}

Boolean HasEventLoaded() {
    return G_EventLoaded;
}

Boolean EventHasCurrentMap(Text _EventHandle, Integer _EventEdition) {
    if (!EventAPI::EventHasContent(_EventHandle)
        || !EventAPI::GetEvent(_EventHandle).EditionsDetails.existskey(_EventEdition))
    {
        return False;
    }

    declare Types::K_EventEditionDetails ThisEvent =
        EventAPI::GetEvent(_EventHandle).EditionsDetails[_EventEdition];

    foreach (Category in ThisEvent.categories) {
        foreach (CatMap in Category.maps) {
            if (CatMap.map_uid == "" ^ Map.Id) {
                return True;
            }
        }
    }
    return False;
}

Boolean HasFailed() {
    return EventAPI::HasFailed()
        || G_Event.expired
        || !EventHasCurrentMap(G_EventHandle, G_EventEdition);
}
Text GetFailReason() {
    if (G_Event.expired) {
        return "The event has expired";
    }
    return EventAPI::GetFailReason();
}

Text GetLastEventHandle() {
    return G_LastEventHandle;
}
Integer GetLastEventEdition() {
    return G_LastEventEdition;
}

Void Init() {
    G_EventLoaded = False;
    G_LastEventHandle = "";
    G_LastEventEdition = -1;
    G_EventHandle = "";
    G_EventEdition = -1;
    G_ForceClear = False;
    EventAPI::Init();
}

Types::K_Event[Text] GetEvents() {
    return EventAPI::GetEvents();
}

Void LoadEdition() {
    EventAPI::Init();

    // We first load the event
    EventAPI::LoadEvent(G_EventHandle);
    while (True) {
        yield;
        EventAPI::Loop();
        if (EventAPI::GetEvents().existskey(G_EventHandle) || EventAPI::HasFailed()) {
            break;
        }
    }

    // Then we load the edition
    EventAPI::LoadEdition(G_EventHandle, G_EventEdition);
    while (True) {
        yield;
        EventAPI::Loop();
        if (EventAPI::EventHasContent(G_EventHandle) || EventAPI::HasFailed()) {
            break;
        }
    }

    if (!EventAPI::HasFailed()) {
        G_Event = EventAPI::GetEvent(G_EventHandle).EditionsDetails[G_EventEdition];
        G_EventLoaded = True;
    }
}

Boolean Loop() {
    return EventAPI::Loop();
}